# Copyright (c) 2025 Amazon.com
# This file is licensed under the MIT License.
# See the LICENSE file in the project root for full license information.

AWSTemplateFormatVersion: "2010-09-09"
Description: Amazon Transcribe Live Meeting Assistant - Virtual Participant

Parameters:
  LMAStackName:
    Type: String
    Description: LMA Stack Name

  # {LMA_USER} token is replaced by user's name at runtime.

  LMAIdentity:
    Type: String
    Default: LMA ({LMA_USER})

  IntroMessage:
    Type: String
    Default: >-
      Hello. I am an AI Live Meeting Assistant (LMA).
      I was invited by {LMA_USER} to join this call. 
      To learn more about me please visit: https://amazon.com/live-meeting-assistant.

  StartRecordingMessage:
    Type: String
    Default: >-
      Live Meeting Assistant started.

  StopRecordingMessage:
    Type: String
    Default: >
      Live Meeting Assistant stopped.

  ExitMessage:
    Type: String
    Default: >
      Live Meeting Assistant has left the room.

  # networking parameters
  VPC:
    Description: VPC ID
    Type: String

  PrivateSubnet1:
    Description: Private subnet 1 for Fargate
    Type: String

  PrivateSubnet2:
    Description: Private subnet 2 for Fargate
    Type: String

  PublicSubnet1:
    Description: Public subnet 1 for ALB
    Type: String

  PublicSubnet2:
    Description: Public subnet 2 for ALB
    Type: String

  LMASettingsParameterName:
    Type: String
    Description: LCA settings SSM Parameter store

  UpdateLMASettingsFunctionArn:
    Type: String
    Description: Update LMA Settings Lambda function ARN

  GraphQLEndpoint:
    Type: String
    Description: AppSync GraphQL endpoint URL for Virtual Participant status updates

  AppSyncEventApiUrl:
    Type: String
    Description: AppSync Event API WebSocket URL for MCP command delivery

  CloudFrontDomainName:
    Type: String
    Description: CloudFront domain name for VNC WebSocket URL construction

  VPTaskRegistryTableName:
    Type: String
    Description: Name of the VPTaskRegistry DynamoDB table from AI stack

  VNCTargetGroupArn:
    Type: String
    Description: ARN of the VNC Target Group from AI stack

  VNCALBListenerArn:
    Type: String
    Description: ARN of the VNC ALB Listener for creating dynamic routing rules

  VPSecurityGroupId:
    Type: String
    Description: Security Group ID for Virtual Participant ECS tasks from AI stack
  
  VirtualParticipantTableName:
    Type: String
    Description: Name of the VirtualParticipant DynamoDB table from AI stack

  VirtualParticipantTableStreamArn:
    Type: String
    Description: ARN of the VirtualParticipant DynamoDB table stream from AI stack


  # container source code
  SourceCodeLocation:
    Type: String
    Description: S3 location of the browser extension source code zipfile

  # transcibe parameters

  EnableAudioRecording:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: >-
      Enable or disable recording of audio during a meeting. If set to false, the
      meeting will not be recorded.
      If set to true, the meeting will be recorded.

  ElevenLabsApiKey:
    Type: String
    NoEcho: true
    Default: ""
    Description: >-
      (Optional) API key for ElevenLabs text-to-speech and conversational AI.
      When provided, enables voice interaction capabilities in Virtual Participant.

  ElevenLabsAgentId:
    Type: String
    Default: ""
    Description: >-
      (Optional) ElevenLabs Conversational AI Agent ID for custom personality.
      Leave blank to use default conversational agent.

  VoiceAssistantProvider:
    Type: String
    Default: "none"
    AllowedValues:
      - "none"
      - "elevenlabs"
      - "aws_nova"
    Description: Voice AI assistant provider (none, elevenlabs, aws_nova)

  VoiceAssistantActivationMode:
    Type: String
    Default: "always_active"
    AllowedValues:
      - "always_active"
      - "wake_phrase"
      - "strands_tool"
    Description: Voice assistant activation mode

  NovaModelId:
    Type: String
    Default: "amazon.nova-2-sonic-v1:0"
    Description: >-
      (Optional) AWS Bedrock Nova model ID for voice assistant.
      Used when VoiceAssistantProvider is set to 'aws_nova'.

  NovaSystemPrompt:
    Type: String
    Default: "You are Alex, an AI meeting assistant. Be concise and helpful."
    Description: >-
      (Optional) System prompt for Nova voice assistant.
      Defines the personality and behavior of the AI assistant.

  S3BucketName:
    Type: String
    Description: >
      Existing bucket where call recording files will be stored.
    # yamllint disable rule:line-length
    AllowedPattern: '( *|(?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$))'
    # yamllint enable rule:line-length

  AudioFilePrefix:
    Type: String
    Default: lma-audio-recordings/
    Description: >-
      The Amazon S3 prefix where the merged output audio files will be saved (must end in "/")

  CallAnalyticsPrefix:
    Type: String
    Default: lca-call-analytics/
    Description: The Amazon S3 prefix where the post-call analytics files will be saved, when using analytics api mode (must end in "/")

  CallDataStreamName:
    Type: String
    Description: >-
      The Name of Kinesis Data Stream to write the call data to.

  TranscribeApiMode:
    Type: String
    Default: standard
    AllowedValues:
      - standard
      - analytics
    Description: Set the default operational mode for Transcribe

  IsContentRedactionEnabled:
    Type: String
    Default: "false"
    Description: >-
      Enable content redaction from Amazon Transcribe transcription output. This is only used when
      the 'en-US' language is selected in the TranscribeLanguageCode parameter.
    AllowedValues:
      - "true"
      - "false"

  TranscribeContentRedactionType:
    Type: String
    Default: PII
    Description: >-
      Type of content redaction from Amazon Transcribe transcription output
    AllowedValues:
      - PII

  TranscribeLanguageCode:
    Type: String
    Description: >-
      Language code or language detection setting for Amazon Transcribe. NOTE: Streaming language identification can't 
      be combined with custom language models or redaction.
    Default: en-US
    AllowedValues:
      - identify-language
      - identify-multiple-languages
      - en-US
      - es-US
      - en-GB
      - fr-CA
      - fr-FR
      - en-AU
      - it-IT
      - de-DE
      - pt-BR
      - ja-JP
      - ko-KR
      - zh-CN
      - hi-IN
      - th-TH

  TranscribeLanguageOptions:
    Type: String
    Default: "en-US, es-US"
    AllowedPattern: '^(?:\s*(?:en-US|es-US|en-GB|fr-CA|fr-FR|en-AU|it-IT|de-DE|pt-BR|ja-JP|ko-KR|zh-CN|hi-IN|th-TH)\s*(?:,\s*(?:en-US|es-US|en-GB|fr-CA|fr-FR|en-AU|it-IT|de-DE|pt-BR|ja-JP|ko-KR|zh-CN|hi-IN|th-TH)\s*)*)?$'
    ConstraintDescription: >-
      Unsupported language code. Allowed values are: en-US, es-US, en-GB, fr-CA, fr-FR, en-AU, it-IT, de-DE, pt-BR, ja-JP, ko-KR, zh-CN, hi-IN, th-TH
    Description: >-
      When TranscribeLanguageCode is set to 'identify-language' or 'identify-multiple-languages',  
      specify two or more comma separated language codes, e.g. "en-US,es-US" that represent the languages you 
      think may be used in your meeting. Including more than five is not recommended. 
      You can select only one language dialect per language per stream - i.e. you cannot select both en-US and en-AU as language options.
      Allowed values are: en-US, es-US, en-GB, fr-CA, fr-FR, en-AU, it-IT, de-DE, pt-BR, ja-JP, ko-KR, zh-CN, hi-IN, th-TH

  TranscribePreferredLanguage:
    Type: String
    Description: >-
      Select a preferred language from the set of language codes you provide for TranscribeLanguageOptions, when 
      TranscribeLanguageCode is set to identify-language or identify-multiple-languages.
    Default: None
    AllowedValues:
      - None
      - en-US
      - es-US
      - en-GB
      - fr-CA
      - fr-FR
      - en-AU
      - it-IT
      - de-DE
      - pt-BR
      - ja-JP
      - ko-KR
      - zh-CN
      - hi-IN
      - th-TH

  TranscribePiiEntityTypes:
    Type: String
    # yamllint disable rule:line-length
    Default: BANK_ACCOUNT_NUMBER,BANK_ROUTING,CREDIT_DEBIT_NUMBER,CREDIT_DEBIT_CVV,CREDIT_DEBIT_EXPIRY,PIN,EMAIL,ADDRESS,NAME,PHONE,SSN
    # yamllint enable rule:line-length
    Description: >-
      Select the PII entity types you want to identify or redact. Remove the values that you don't
      want to redact from the default.  DO NOT ADD CUSTOM VALUES HERE.

  CustomVocabularyName:
    Type: String
    Default: ""
    Description: >-
      The name of the vocabulary to use when processing the transcription job. Leave blank if no
      custom vocabulary to be used. If yes, the custom vocabulary must pre-exist in your account.

  CustomLanguageModelName:
    Type: String
    Default: ""
    Description: >-
      The name of the custom language model to use when processing the transcription job. Leave blank if no
      custom language model is to be used. If yes, the custom language model must pre-exist in your account.

  ShowSpeakerLabel:
    Type: String
    Default: "false"
    Description: >-
      Enable diarization on Transcribe streaming
    AllowedValues:
      - "true"
      - "false"

  CloudWatchLogsExpirationInDays:
    Type: Number
    Default: 14
    Description: The number of days log events are kept in CloudWatch Logs.

  CustomerManagedEncryptionKeyArn:
    Type: String
    Description: ARN of the customer managed KMS key for encryption

  PermissionsBoundaryArn:
    Type: String
    Default: ""
    Description: >-
      (Optional) ARN of an existing IAM managed policy to use as permissions boundary for IAM roles.
      If provided, this policy will limit the maximum permissions that can be granted to IAM roles
      in this stack, providing an additional layer of security.

  # Startup Optimization Parameters
  VPLaunchType:
    Type: String
    Default: EC2
    AllowedValues:
      - FARGATE
      - EC2
    Description: Launch type for Virtual Participant containers (FARGATE with SOCI or EC2 with caching)

  VPInstanceType:
    Type: String
    Default: t3.medium
    AllowedValues:
      - t3.small
      - t3.medium
      - t3.large
      - t3.xlarge
    Description: EC2 instance type (only used if VPLaunchType=EC2)

  VPMinInstances:
    Type: Number
    Default: 1
    MinValue: 0
    MaxValue: 10
    Description: Minimum warm EC2 instances (only used if VPLaunchType=EC2)

  VPMaxInstances:
    Type: Number
    Default: 10
    MinValue: 1
    MaxValue: 100
    Description: Maximum EC2 instances (only used if VPLaunchType=EC2)


Conditions:
  HasPermissionsBoundary: !Not [!Equals [!Ref PermissionsBoundaryArn, ""]]
  ShouldEnableContentRedaction: !And
    - !Equals [!Ref IsContentRedactionEnabled, "true"]
    - !Equals [!Ref TranscribeLanguageCode, "en-US"]
  UseEC2LaunchType: !Equals [!Ref VPLaunchType, "EC2"]
  UseFargateLaunchType: !Equals [!Ref VPLaunchType, "FARGATE"]

Resources:
  LogsPolicy:
    Type: "AWS::IAM::ManagedPolicy"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W13
            reason: "CloudWatch Logs requires broad access for log group and stream creation"
    # checkov:skip=CKV_AWS_111: "CloudWatch Logs requires broad access for log group and stream creation"
    Properties:
      Path: /
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Action:
              - "logs:CreateLogGroup"
              - "logs:CreateLogStream"
              - "logs:PutLogEvents"
            Resource: "*"

  ### Build Resources ###
  ImageRepo:
    Type: AWS::ECR::Repository
    Properties:
      EmptyOnDelete: true
      ImageTagMutability: MUTABLE
      ImageScanningConfiguration:
        ScanOnPush: true
      EncryptionConfiguration:
        EncryptionType: KMS
        KmsKey: !Ref CustomerManagedEncryptionKeyArn

  BuildRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "codebuild.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: "ECRPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub "arn:aws:s3:::${SourceCodeLocation}"
              - Effect: "Allow"
                Action:
                  - "ecr:BatchCheckLayerAvailability"
                  - "ecr:BatchGetImage"
                  - "ecr:GetDownloadUrlForLayer"
                  - "ecr:CompleteLayerUpload"
                  - "ecr:InitiateLayerUpload"
                  - "ecr:PutImage"
                  - "ecr:UploadLayerPart"
                Resource:
                  - !GetAtt ImageRepo.Arn
              - Effect: "Allow"
                Action:
                  - "ecr:GetAuthorizationToken"
                Resource:
                  - "*"
        - PolicyName: "ECSDeploymentPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "ecs:UpdateService"
                  - "ecs:DescribeServices"
                  - "ecs:ListServices"
                  - "ecs:DescribeClusters"
                  - "ecs:ListContainerInstances"
                  - "ecs:DescribeContainerInstances"
                Resource:
                  - "*"
              - Effect: "Allow"
                Action:
                  - "autoscaling:DescribeAutoScalingGroups"
                  - "autoscaling:TerminateInstanceInAutoScalingGroup"
                  - "autoscaling:SetDesiredCapacity"
                Resource:
                  - "*"
              - Effect: "Allow"
                Action:
                  - "ec2:DescribeInstances"
                  - "ec2:TerminateInstances"
                Resource:
                  - "*"

  VirtualParticipantBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Source:
        Location: !Sub "arn:aws:s3:::${SourceCodeLocation}"
        Type: S3
        BuildSpec: !Sub
          - |
            version: 0.2
            phases:
              pre_build:
                commands:
                  - echo Logging in to Amazon ECR...
                  - aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com
                  - echo Installing SOCI CLI for image optimization...
                  - wget --quiet https://github.com/awslabs/soci-snapshotter/releases/download/v0.12.1/soci-snapshotter-0.12.1-linux-amd64.tar.gz
                  - tar xzf soci-snapshotter-0.12.1-linux-amd64.tar.gz soci
                  - mv soci /usr/local/bin/soci
                  - soci --version
                  - echo SOCI CLI installed successfully
                  - export PASSWORD=$(aws ecr get-login-password --region ${AWS::Region})
              build:
                commands:
                  - echo Build started on `date`
                  - echo `pwd`
                  - echo `ls -altr`
                  - echo Building container image...
                  - docker build -t ${ImageRepo} backend
                  - docker tag ${ImageRepo}:latest ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest
                  - echo Pushing image to ECR...
                  - docker push ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest
                  - echo Exporting image for SOCI indexing...
                  - docker save ${ImageRepo}:latest -o ./image.tar
                  - echo Importing image to containerd...
                  - ctr image import ./image.tar
                  - echo Tagging for SOCI...
                  - ctr image tag docker.io/library/${ImageRepo}:latest ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest
              post_build:
                commands:
                  - echo Generating SOCI index for faster startup...
                  - soci create ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest
                  - echo Pushing SOCI index to ECR...
                  - soci push --user AWS:$PASSWORD ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest
                  - echo Build completed on `date`
                  - |
                    echo "Deploying new image to ECS..."
                    # Find the ECS service for this stack
                    CLUSTER_ARN="${ClusterArn}"
                    SERVICE_NAME=$(aws ecs list-services --cluster $CLUSTER_ARN --region ${AWS::Region} --query 'serviceArns[0]' --output text)
                    
                    if [ "$SERVICE_NAME" != "None" ] && [ -n "$SERVICE_NAME" ]; then
                      echo "Found ECS service: $SERVICE_NAME"
                      
                      # Get service details to determine launch type
                      LAUNCH_TYPE=$(aws ecs describe-services --cluster $CLUSTER_ARN --services $SERVICE_NAME --region ${AWS::Region} --query 'services[0].launchType' --output text)
                      echo "Launch type: $LAUNCH_TYPE"
                      
                      # Force new deployment to pull latest image
                      echo "Forcing ECS service update to deploy new image..."
                      aws ecs update-service --cluster $CLUSTER_ARN --service $SERVICE_NAME --force-new-deployment --region ${AWS::Region}
                      
                      # For EC2 launch type, terminate instances to force fresh pull
                      if [ "$LAUNCH_TYPE" = "EC2" ]; then
                        echo "EC2 launch type detected - terminating instances to force image refresh..."
                        
                        # Get container instances
                        CONTAINER_INSTANCES=$(aws ecs list-container-instances --cluster $CLUSTER_ARN --region ${AWS::Region} --query 'containerInstanceArns' --output text)
                        
                        if [ -n "$CONTAINER_INSTANCES" ]; then
                          # Get EC2 instance IDs from container instances
                          for CONTAINER_INSTANCE in $CONTAINER_INSTANCES; do
                            EC2_INSTANCE_ID=$(aws ecs describe-container-instances --cluster $CLUSTER_ARN --container-instances $CONTAINER_INSTANCE --region ${AWS::Region} --query 'containerInstances[0].ec2InstanceId' --output text)
                            
                            if [ -n "$EC2_INSTANCE_ID" ] && [ "$EC2_INSTANCE_ID" != "None" ]; then
                              echo "Terminating EC2 instance: $EC2_INSTANCE_ID"
                              
                              # Check if instance is in an Auto Scaling Group
                              ASG_NAME=$(aws autoscaling describe-auto-scaling-instances --instance-ids $EC2_INSTANCE_ID --region ${AWS::Region} --query 'AutoScalingInstances[0].AutoScalingGroupName' --output text 2>/dev/null || echo "")
                              
                              if [ -n "$ASG_NAME" ] && [ "$ASG_NAME" != "None" ]; then
                                echo "Instance is in ASG: $ASG_NAME - terminating via ASG..."
                                aws autoscaling terminate-instance-in-auto-scaling-group --instance-id $EC2_INSTANCE_ID --should-decrement-desired-capacity false --region ${AWS::Region}
                              else
                                echo "Instance not in ASG - terminating directly..."
                                aws ec2 terminate-instances --instance-ids $EC2_INSTANCE_ID --region ${AWS::Region}
                              fi
                            fi
                          done
                          echo "EC2 instances terminated. Auto Scaling will launch new instances with fresh Docker image."
                        else
                          echo "No container instances found in cluster."
                        fi
                      else
                        echo "FARGATE launch type - service update will automatically use new image."
                      fi
                      
                      echo "Deployment initiated successfully!"
                    else
                      echo "No ECS service found in cluster - skipping deployment."
                    fi
          - { ImageRepo: !Ref ImageRepo, ClusterArn: !GetAtt Cluster.Arn }
      Environment:
        Type: LINUX_CONTAINER
        Image: aws/codebuild/amazonlinux2-x86_64-standard:5.0
        ComputeType: BUILD_GENERAL1_SMALL
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: SOURCE_CODE_LOCATION
            Value: !Sub "${SourceCodeLocation}"
          - Name: CONTAINERD_ADDRESS
            Value: "/var/run/docker/containerd/containerd.sock"
      ServiceRole: !GetAtt BuildRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS

  ### Custom Resources ###

  BuildCustomResourceRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "CodeBuild integration requires broad access for build project management"
    # checkov:skip=CKV_AWS_111: "CodeBuild integration requires broad access for build project management"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: "/"
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: BuildPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource:
                  - "*"

  BuildCustomResourceFunction:
    Type: "AWS::Lambda::Function"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access as it only interacts with AWS services via APIs
          - id: W92
            reason: Function does not require reserved concurrency as it scales based on demand
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    Properties:
      Handler: index.handler
      Role: !GetAtt BuildCustomResourceRole.Arn
      Timeout: 900
      Runtime: python3.12
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: !Sub |
          import boto3
          from time import sleep
          import cfnresponse

          def handler(event, context):

            request_type = event['RequestType']
            print(request_type)

            if request_type in ['Create', 'Update']:
              client = boto3.client("codebuild")

              build_id = client.start_build(
                projectName=event['ResourceProperties']['PROJECT']
              )['build']['id']
              status = 'STARTING'

              while status != 'SUCCEEDED':
                if status in ['FAILED', 'FAULT', 'TIMED_OUT', 'STOPPED']:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})
                  return
                sleep(15)
                status = client.batch_get_builds(ids=[build_id])['builds'][0]['buildStatus']
                print(status)

            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

  BuildCustomResource:
    Type: Custom::BuildCode
    Properties:
      ServiceToken: !GetAtt BuildCustomResourceFunction.Arn
      PROJECT: !Ref VirtualParticipantBuildProject
      SOURCE_CODE_LOCATION: !Sub "${SourceCodeLocation}"

  ECSRoleCustomResourceRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "ECS service-linked role creation requires broad IAM access"
    # checkov:skip=CKV_AWS_109: "ECS service-linked role creation requires broad IAM permissions management access"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: "/"
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: IAMPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:GetRole
                  - iam:CreateServiceLinkedRole
                  - iam:ListRoles
                  - iam:AttachRolePolicy
                Resource:
                  - "*"

  ECSRoleCustomResourceFunction:
    Type: "AWS::Lambda::Function"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access as it only interacts with AWS services via APIs
          - id: W92
            reason: Function does not require reserved concurrency as it scales based on demand
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    Properties:
      Handler: index.handler
      Role: !GetAtt ECSRoleCustomResourceRole.Arn
      Timeout: 300
      Runtime: python3.12
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: !Sub |
          import boto3
          from botocore.exceptions import ClientError
          import cfnresponse

          def handler(event, context):
              
            request_type = event['RequestType']
            print(request_type)

            if request_type == 'Create':
              desired_role_name = "AWSServiceRoleForECS"
              iam_client = boto3.client('iam')

              try:
                iam_client.get_role(RoleName=desired_role_name)
                role_exists = True
              except ClientError as e:
                if e.response['Error']['Code'] == 'NoSuchEntity':
                  role_exists = False
                else:
                  raise

              print(role_exists)
              if not role_exists:
                iam_client.create_service_linked_role(AWSServiceName="ecs.amazonaws.com")

            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

  ECSRoleCustomResource:
    Type: Custom::ECSRole
    Properties:
      ServiceToken: !GetAtt ECSRoleCustomResourceFunction.Arn

  TaskRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "Virtual participant requires broad Transcribe and Comprehend access for real-time processing"
    # checkov:skip=CKV_AWS_111: "Virtual participant requires broad Transcribe and Comprehend access for real-time processing"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: LMAPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject*
                  - s3:GetBucket*
                  - s3:List*
                  - s3:DeleteObject*
                  - s3:PutObject
                  - s3:PutObjectLegalHold
                  - s3:PutObjectRetention
                  - s3:PutObjectTagging
                  - s3:PutObjectVersionTagging
                  - s3:Abort*
                Resource:
                  - !Sub
                    - "arn:aws:s3:::${bucket}"
                    - bucket: !Ref S3BucketName
                  - !Sub
                    - "arn:aws:s3:::${bucket}/*"
                    - bucket: !Ref S3BucketName
              - Effect: Allow
                Action:
                  - kinesis:PutRecord
                  - kinesis:PutRecords
                  - kinesis:DescribeStream
                Resource:
                  - !Sub "arn:${AWS::Partition}:kinesis:${AWS::Region}:${AWS::AccountId}:stream/${CallDataStreamName}"
        - PolicyName: TranscribePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - transcribe:DeleteTranscriptionJob
                  - transcribe:GetTranscriptionJob
                  - transcribe:GetVocabulary
                  - transcribe:ListTranscriptionJobs
                  - transcribe:ListVocabularies
                  - transcribe:StartStreamTranscription
                  - transcribe:StartTranscriptionJob
                  - transcribe:StartCallAnalyticsStreamTranscription
                Resource: "*"
        - PolicyName: DetectPIIPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "comprehend:DetectPiiEntities"
                Resource: "*"
        - PolicyName: AppSyncPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "appsync:GraphQL"
                  - "appsync:EventConnect"
                  - "appsync:EventSubscribe"
                  - "appsync:EventPublish"
                Resource: "*"
        - PolicyName: VirtualParticipantTablePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:UpdateItem"
                  - "dynamodb:GetItem"
                Resource: !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/*VirtualParticipant*"
        - PolicyName: VPTaskRegistryPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:PutItem"
                  - "dynamodb:GetItem"
                  - "dynamodb:UpdateItem"
                Resource:
                  - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${VPTaskRegistryTableName}"
        - PolicyName: ALBDynamicRoutingPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "elasticloadbalancing:CreateTargetGroup"
                  - "elasticloadbalancing:DeleteTargetGroup"
                  - "elasticloadbalancing:DescribeTargetGroups"
                  - "elasticloadbalancing:ModifyTargetGroupAttributes"
                  - "elasticloadbalancing:RegisterTargets"
                  - "elasticloadbalancing:DeregisterTargets"
                  - "elasticloadbalancing:DescribeTargetHealth"
                  - "elasticloadbalancing:CreateRule"
                  - "elasticloadbalancing:DeleteRule"
                  - "elasticloadbalancing:DescribeRules"
                  - "elasticloadbalancing:ModifyRule"
                  - "elasticloadbalancing:AddTags"
                Resource: "*"
        - PolicyName: BedrockPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "bedrock:InvokeModel"
                  - "bedrock:InvokeModelWithResponseStream"
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.nova-*"

  TaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      MaxSessionDuration: 36000
      ManagedPolicyArns:
        # AWS managed policies required to allow ECS task to function properly.
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceEventsRole
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        - !GetAtt LogsPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue

  Cluster:
    Type: "AWS::ECS::Cluster"
    Properties:
      CapacityProviders:
        - FARGATE
      ClusterSettings:
        - Name: containerInsights
          Value: enabled
    DependsOn:
      - ECSRoleCustomResource

  # EC2 Launch Type Resources (conditional)
  
  VPInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Condition: UseEC2LaunchType
    Properties:
      Roles:
        - !Ref VPInstanceRole

  VPInstanceRole:
    Type: AWS::IAM::Role
    Condition: UseEC2LaunchType
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue

  VPLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Condition: UseEC2LaunchType
    Properties:
      LaunchTemplateName: !Sub "${AWS::StackName}-VP-LaunchTemplate"
      LaunchTemplateData:
        ImageId: !Sub '{{resolve:ssm:/aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id}}'
        InstanceType: !Ref VPInstanceType
        IamInstanceProfile:
          Arn: !GetAtt VPInstanceProfile.Arn
        SecurityGroupIds:
          - !Ref VPSecurityGroupId
        MetadataOptions:
          HttpTokens: required
          HttpPutResponseHopLimit: 1
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            set -e
            echo "ECS_CLUSTER=${Cluster}" >> /etc/ecs/ecs.config
            echo "ECS_IMAGE_PULL_BEHAVIOR=prefer-cached" >> /etc/ecs/ecs.config
            echo "ECS_ENABLE_CONTAINER_METADATA=true" >> /etc/ecs/ecs.config
            echo "ECS_ENABLE_TASK_IAM_ROLE=true" >> /etc/ecs/ecs.config
            echo "ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=true" >> /etc/ecs/ecs.config
            aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com
            docker pull ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest
            systemctl enable --now ecs

  # Custom Resource to handle ASG deletion gracefully
  ASGDeletionHandlerRole:
    Type: AWS::IAM::Role
    Condition: UseEC2LaunchType
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: ASGDeletionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - autoscaling:DescribeAutoScalingGroups
                  - autoscaling:DescribeAutoScalingInstances
                  - autoscaling:SetInstanceProtection
                  - autoscaling:UpdateAutoScalingGroup
                  - autoscaling:TerminateInstanceInAutoScalingGroup
                  - ec2:DescribeInstances
                Resource: "*"

  ASGDeletionHandlerFunction:
    Type: AWS::Lambda::Function
    Condition: UseEC2LaunchType
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access as it only interacts with AWS services via APIs
          - id: W92
            reason: Function does not require reserved concurrency as it scales based on demand
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    Properties:
      Handler: index.handler
      Role: !GetAtt ASGDeletionHandlerRole.Arn
      Timeout: 300
      Runtime: python3.12
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          autoscaling = boto3.client('autoscaling')
          
          def handler(event, context):
              logger.info(f"Event: {event}")
              request_type = event['RequestType']
              asg_name = event['ResourceProperties'].get('AutoScalingGroupName')
              
              try:
                  if request_type == 'Delete':
                      logger.info(f"Preparing ASG {asg_name} for deletion")
                      
                      # Get ASG details
                      try:
                          response = autoscaling.describe_auto_scaling_groups(
                              AutoScalingGroupNames=[asg_name]
                          )
                          
                          if not response['AutoScalingGroups']:
                              logger.info(f"ASG {asg_name} not found, assuming already deleted")
                              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                              return
                          
                          asg = response['AutoScalingGroups'][0]
                          instances = asg.get('Instances', [])
                          
                          logger.info(f"Found {len(instances)} instances in ASG")
                          
                          # Remove scale-in protection from all instances
                          if instances:
                              instance_ids = [i['InstanceId'] for i in instances]
                              logger.info(f"Removing scale-in protection from instances: {instance_ids}")
                              
                              autoscaling.set_instance_protection(
                                  InstanceIds=instance_ids,
                                  AutoScalingGroupName=asg_name,
                                  ProtectedFromScaleIn=False
                              )
                              
                              logger.info("Scale-in protection removed successfully")
                              
                              # Set desired capacity to 0 to trigger instance termination
                              logger.info("Setting ASG desired capacity to 0")
                              autoscaling.update_auto_scaling_group(
                                  AutoScalingGroupName=asg_name,
                                  MinSize=0,
                                  DesiredCapacity=0
                              )
                              
                              # Wait a bit for instances to start terminating
                              time.sleep(5)
                              
                              # Force terminate any remaining instances
                              for instance_id in instance_ids:
                                  try:
                                      logger.info(f"Force terminating instance {instance_id}")
                                      autoscaling.terminate_instance_in_auto_scaling_group(
                                          InstanceId=instance_id,
                                          ShouldDecrementDesiredCapacity=False
                                      )
                                  except Exception as e:
                                      logger.warning(f"Failed to terminate instance {instance_id}: {e}")
                              
                              logger.info("All instances terminated or terminating")
                          else:
                              logger.info("No instances to terminate")
                          
                      except autoscaling.exceptions.ClientError as e:
                          if 'does not exist' in str(e):
                              logger.info(f"ASG {asg_name} already deleted")
                          else:
                              raise
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  
              except Exception as e:
                  logger.error(f"Error handling ASG deletion: {e}", exc_info=True)
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason=str(e))

  ASGDeletionHandler:
    Type: Custom::ASGDeletionHandler
    Condition: UseEC2LaunchType
    Properties:
      ServiceToken: !GetAtt ASGDeletionHandlerFunction.Arn
      AutoScalingGroupName: !Sub "${AWS::StackName}-VP-ASG"
    DependsOn:
      - VPAutoScalingGroup

  VPAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Condition: UseEC2LaunchType
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      AutoScalingGroupName: !Sub "${AWS::StackName}-VP-ASG"
      MinSize: !Ref VPMinInstances
      MaxSize: !Ref VPMaxInstances
      DesiredCapacity: !Ref VPMinInstances
      HealthCheckType: EC2
      HealthCheckGracePeriod: 300
      LaunchTemplate:
        LaunchTemplateId: !Ref VPLaunchTemplate
        Version: !GetAtt VPLaunchTemplate.LatestVersionNumber
      VPCZoneIdentifier:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      NewInstancesProtectedFromScaleIn: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-VP-Instance"
          PropagateAtLaunch: true

  VPCapacityProvider:
    Type: AWS::ECS::CapacityProvider
    Condition: UseEC2LaunchType
    Properties:
      Name: !Sub "${AWS::StackName}-VP-CapacityProvider"
      AutoScalingGroupProvider:
        AutoScalingGroupArn: !Ref VPAutoScalingGroup
        ManagedScaling:
          Status: ENABLED
          TargetCapacity: 100
          MinimumScalingStepSize: 1
          MaximumScalingStepSize: 10
        ManagedTerminationProtection: ENABLED

  TaskDefinition:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      ContainerDefinitions:
        - Memory: !If [UseEC2LaunchType, 3500, !Ref AWS::NoValue]
          Environment:
            - Name: AWS_REGION
              Value: !Ref AWS::Region
            - Name: SHOULD_RECORD_CALL
              Value: !Ref EnableAudioRecording
            - Name: RECORDINGS_BUCKET_NAME
              Value: !Ref S3BucketName
            - Name: RECORDINGS_KEY_PREFIX
              Value: !Ref AudioFilePrefix
            - Name: CALL_ANALYTICS_FILE_PREFIX
              Value: !Ref CallAnalyticsPrefix
            - Name: POST_CALL_CONTENT_REDACTION_OUTPUT
              Value: "redacted"
            - Name: SERVERHOST
              Value: "0.0.0.0"
            - Name: SERVERPORT
              Value: "8080"
            - Name: KINESIS_STREAM_NAME
              Value: !Ref CallDataStreamName
            - Name: CALL_DATA_STREAM_NAME
              Value: !Ref CallDataStreamName
            - Name: SAVE_PARTIAL_TRANSCRIPTS
              Value: "true"
            - Name: SHOW_SPEAKER_LABEL
              Value: !Ref ShowSpeakerLabel
            - Name: TRANSCRIBE_API_MODE
              Value: !Ref TranscribeApiMode
            - Name: IS_CONTENT_REDACTION_ENABLED
              Value: !If
                - ShouldEnableContentRedaction
                - "true"
                - "false"
            - Name: ENABLE_CONTENT_REDACTION
              Value: !If
                - ShouldEnableContentRedaction
                - "true"
                - "false"
            - Name: CONTENT_REDACTION_TYPE
              Value: !Ref TranscribeContentRedactionType
            - Name: TRANSCRIBE_CONTENT_REDACTION_TYPE
              Value: !Ref TranscribeContentRedactionType
            - Name: TRANSCRIBE_PII_ENTITY_TYPES
              Value: !Ref TranscribePiiEntityTypes
            - Name: TRANSCRIBE_LANGUAGE_CODE
              Value: !Ref TranscribeLanguageCode
            - Name: TRANSCRIBE_LANGUAGE_OPTIONS
              Value: !Ref TranscribeLanguageOptions
            - Name: TRANSCRIBE_PREFERRED_LANGUAGE
              Value: !Ref TranscribePreferredLanguage
            - Name: CUSTOM_VOCABULARY_NAME
              Value: !Ref CustomVocabularyName
            - Name: CUSTOM_LANGUAGE_MODEL_NAME
              Value: !Ref CustomLanguageModelName
            - Name: LMA_IDENTITY
              Value: !Ref LMAIdentity
            - Name: INTRO_MESSAGE
              Value: !Ref IntroMessage
            - Name: START_RECORDING_MESSAGE
              Value: !Ref StartRecordingMessage
            - Name: STOP_RECORDING_MESSAGE
              Value: !Ref StopRecordingMessage
            - Name: EXIT_MESSAGE
              Value: !Ref ExitMessage
            - Name: GRAPHQL_ENDPOINT
              Value: !Ref GraphQLEndpoint
            - Name: APPSYNC_EVENTS_URL
              Value: !Ref AppSyncEventApiUrl
            - Name: VP_TASK_REGISTRY_TABLE_NAME
              Value: !Ref VPTaskRegistryTableName
            - Name: ENABLE_AUDIO_RECORDING
              Value: !Ref EnableAudioRecording
            - Name: CLOUDFRONT_DOMAIN
              Value: !Ref CloudFrontDomainName
            - Name: VNC_TARGET_GROUP_ARN
              Value: !Ref VNCTargetGroupArn
            - Name: VPC_ID
              Value: !Ref VPC
            - Name: ALB_LISTENER_ARN
              Value: !Ref VNCALBListenerArn
            - Name: ELEVENLABS_API_KEY
              Value: !Ref ElevenLabsApiKey
            - Name: ELEVENLABS_AGENT_ID
              Value: !Ref ElevenLabsAgentId
            - Name: VOICE_ASSISTANT_PROVIDER
              Value: !Ref VoiceAssistantProvider
            - Name: VOICE_ASSISTANT_ACTIVATION_MODE
              Value: !Ref VoiceAssistantActivationMode
            - Name: NOVA_MODEL_ID
              Value: !Ref NovaModelId
            - Name: NOVA_SYSTEM_PROMPT
              Value: !Ref NovaSystemPrompt
          Essential: true
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}:latest"
          PortMappings:
            - ContainerPort: 5901
              Protocol: tcp
              Name: vnc-websocket
          LogConfiguration:
            LogDriver: "awslogs"
            Options:
              awslogs-group:
                Ref: VirtualParticipantTaskDefContainerLogGroup
              awslogs-stream-prefix: lmavirtualparticipant
              awslogs-region:
                Ref: AWS::Region
          Name: "scribe"
      Family: !Sub ${AWS::StackName}VirtualParticipantTaskDef
      TaskRoleArn: !Ref TaskRole
      ExecutionRoleArn: !GetAtt TaskExecutionRole.Arn
      NetworkMode: "awsvpc"
      RequiresCompatibilities: !If
        - UseEC2LaunchType
        - - EC2
        - - FARGATE
      Cpu: !If [UseFargateLaunchType, "1 vCPU", !Ref AWS::NoValue]
      Memory: !If [UseFargateLaunchType, "4 GB", !Ref AWS::NoValue]
    DependsOn:
      - Cluster
      - BuildCustomResource

  # ECS Service to register tasks with target group
  VirtualParticipantService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: !Sub "${LMAStackName}-vp-service-${VPLaunchType}"
      Cluster: !Ref Cluster
      TaskDefinition: !Ref TaskDefinition
      DesiredCount: 0
      LaunchType: !Ref VPLaunchType
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref VPSecurityGroupId
          Subnets:
            - !Ref PrivateSubnet1
            - !Ref PrivateSubnet2
      LoadBalancers:
        - ContainerName: scribe
          ContainerPort: 5901
          TargetGroupArn: !Ref VNCTargetGroupArn
      PlacementStrategies: !If
        - UseEC2LaunchType
        - - Type: spread
            Field: instanceId
        - !Ref AWS::NoValue

  VirtualParticipantTaskDefContainerLogGroup:
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/fargate/VirtualParticipant
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: >-
              By default CloudWatchLogs LogGroups data is encrypted using the CloudWatch
              server-side encryption keys (AWS Managed Keys).

  ### Scheduler Resources ###

  ScheduleGroup:
    Type: AWS::Scheduler::ScheduleGroup

  ECSPolicy:
    Type: AWS::IAM::ManagedPolicy
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W13
            reason: "ECS task scheduling requires broad access for task execution and role passing"
    # checkov:skip=CKV_AWS_111: "ECS task scheduling requires broad access for task execution and role passing"
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - "ecs:RunTask"
            Resource: "*"
          - Effect: Allow
            Action: iam:PassRole
            Resource: "*"
            Condition:
              StringLike:
                iam:PassedToService: ecs-tasks.amazonaws.com

  TargetECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - scheduler.amazonaws.com
                - events.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
        - !GetAtt ECSPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: TagPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: ecs:TagResource
                Resource: "*"
                Condition:
                  StringEquals:
                    ecs:CreateAction:
                      - RunTask

  SchedulerStateMachineLogGroup:
    Type: "AWS::Logs::LogGroup"
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      RetentionInDays: 7
      LogGroupName: !Sub "/aws/vendedlogs/states/${AWS::StackName}"
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  LMAVirtualParticipantSchedulerStateMachineRole:
    Type: "AWS::IAM::Role"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "Step Functions state machine requires broad access for logging, tracing, and scheduling operations"
    # checkov:skip=CKV_AWS_111: "Step Functions state machine requires broad access for logging, tracing, and scheduling operations"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: states.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      ManagedPolicyArns:
        - !GetAtt ECSPolicy.PolicyArn
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: ExpandedLogsPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogDelivery"
                  - "logs:CreateLogStream"
                  - "logs:GetLogDelivery"
                  - "logs:UpdateLogDelivery"
                  - "logs:DeleteLogDelivery"
                  - "logs:ListLogDeliveries"
                  - "logs:PutLogEvents"
                  - "logs:PutResourcePolicy"
                  - "logs:DescribeResourcePolicies"
                  - "logs:DescribeLogGroups"
                Resource: "*"
        - PolicyName: TracesPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: "*"
        - PolicyName: SchedulePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - scheduler:CreateSchedule
                  - scheduler:ListSchedules
                  - scheduler:GetSchedule
                  - scheduler:UpdateSchedule
                  - scheduler:DeleteSchedule
                Resource:
                  - arn:aws:scheduler:*:*:schedule/*
                  - arn:aws:scheduler:*:*:schedule-group/default
        - PolicyName: PassRolePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: iam:PassRole
                Resource: !GetAtt TargetECSRole.Arn
                Condition:
                  StringLike:
                    iam:PassedToService: scheduler.amazonaws.com
        - PolicyName: DynamoDBPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:UpdateItem
                  - dynamodb:GetItem
                Resource: !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/*VirtualParticipant*"

  LMAVirtualParticipantSchedulerStateMachine:
    Type: "AWS::StepFunctions::StateMachine"
    Properties:
      # StateMachine name is used in policy in AISTACK template
      StateMachineName: !Sub "${LMAStackName}-LMAVirtualParticipantScheduler"
      RoleArn: !GetAtt [LMAVirtualParticipantSchedulerStateMachineRole, Arn]
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn: !GetAtt
                - SchedulerStateMachineLogGroup
                - Arn
        IncludeExecutionData: true
        Level: ALL
      StateMachineType: EXPRESS
      TracingConfiguration:
        Enabled: true
      DefinitionString: !Sub
        - |
          {
            "StartAt": "Method Choice",
            "States": {
              "Method Choice": {
                "Type": "Choice",
                "Choices": [
                  {
                    "Variable": "$.apiInfo.httpMethod",
                    "StringEquals": "POST",
                    "Next": "Time Choice"
                  },
                  {
                    "Variable": "$.apiInfo.httpMethod",
                    "StringEquals": "GET",
                    "Next": "ListSchedules"
                  },
                  {
                    "Variable": "$.apiInfo.httpMethod",
                    "StringEquals": "DELETE",
                    "Next": "DeleteSchedule"
                  }
                ],
                "Default": "Pass"
              },
              "Time Choice": {
                "Type": "Choice",
                "Choices": [
                  {
                    "Not": {
                      "Variable": "$.data.meetingTime",
                      "StringMatches": ""
                    },
                    "Next": "CreateSchedule"
                  }
                ],
                "Default": "RunTask"
              },
              "RunTask": {
                "Type": "Task",
                "Resource": "arn:${AWS::Partition}:states:::ecs:runTask",
                "Parameters": {
                  "Cluster": "${ClusterArn}",
                  "TaskDefinition": "${TaskDefinition}",
                  "LaunchType": "${VPLaunchType}",
                  "NetworkConfiguration": {
                    "AwsvpcConfiguration": {
                      "AssignPublicIp": "DISABLED",
                      "SecurityGroups": [
                        "${VPSecurityGroupId}"
                      ],
                      "Subnets": [
                        "${PrivateSubnet1}",
                        "${PrivateSubnet2}"
                      ]
                    }
                  },
                  "Overrides": {
                    "ContainerOverrides": [
                      {
                        "Name": "scribe",
                        "Environment": [
                          {
                            "Name": "MEETING_PLATFORM",
                            "Value.$": "$.data.meetingPlatform"
                          },
                          {
                            "Name": "MEETING_ID",
                            "Value.$": "$.data.meetingID"
                          },
                          {
                            "Name": "MEETING_PASSWORD",
                            "Value.$": "$.data.meetingPassword"
                          },
                          {
                            "Name": "MEETING_NAME",
                            "Value.$": "$.data.meetingName"
                          },
                          {
                            "Name": "LMA_USER",
                            "Value.$": "$.data.userName"
                          },
                          {
                            "Name": "USER_ACCESS_TOKEN",
                            "Value.$": "$.data.accessToken"
                          },
                          {
                            "Name": "USER_ID_TOKEN",
                            "Value.$": "$.data.idToken"
                          },
                          {
                            "Name": "USER_REFRESH_TOKEN",
                            "Value.$": "$.data.rereshToken"
                          },
                          {
                            "Name": "VIRTUAL_PARTICIPANT_ID",
                            "Value.$": "$.data.virtualParticipantId"
                          }
                        ]
                      }
                    ]
                  }
                },
                "End": true,
                "ResultSelector": {
                  "failures.$": "$.Failures"
                }
              },
              "CreateSchedule": {
                "Type": "Task",
                "Parameters": {
                  "ActionAfterCompletion": "DELETE",
                  "Description.$": "States.Format('{}_{}', $.data.meetingPlatform, $.data.meetingName)",
                  "FlexibleTimeWindow": {
                    "Mode": "OFF"
                  },
                  "GroupName": "${ScheduleGroup}",
                  "Name.$": "States.Format('{}_{}_{}_{}', $.data.meetingPlatform, $.data.meetingName, $.data.meetingID, States.MathRandom(0, 1000000))",
                  "ScheduleExpression.$": "States.Format('at({})', $.data.meetingTime)",
                  "ScheduleExpressionTimezone": "UTC",
                  "State": "ENABLED",
                  "Target": {
                    "Arn": "${ClusterArn}",
                    "RoleArn": "${TargetECSRoleArn}",
                    "EcsParameters": {
                      "EnableECSManagedTags": false,
                      "EnableExecuteCommand": false,
                      "LaunchType": "${VPLaunchType}",
                      "NetworkConfiguration": {
                        "AwsvpcConfiguration": {
                          "AssignPublicIp": "DISABLED",
                          "SecurityGroups": [
                            "${VPSecurityGroupId}"
                          ],
                          "Subnets": [
                            "${PrivateSubnet1}",
                            "${PrivateSubnet2}"
                          ]
                        }
                      },
                      "TaskCount": 1,
                      "TaskDefinitionArn": "${TaskDefinition}"
                    },
                    "Input": {
                      "containerOverrides": [
                        {
                          "name": "scribe",
                          "environment": [
                            {
                              "name": "MEETING_PLATFORM",
                              "value.$": "$.data.meetingPlatform"
                            },
                            {
                              "name": "MEETING_ID",
                              "value.$": "$.data.meetingID"
                            },
                            {
                              "name": "MEETING_PASSWORD",
                              "value.$": "$.data.meetingPassword"
                            },
                            {
                              "name": "MEETING_NAME",
                              "value.$": "$.data.meetingName"
                            },
                            {
                              "Name": "LMA_USER",
                              "Value.$": "$.data.userName"
                            }
                          ]
                        }
                      ]
                    }
                  }
                },
                "Resource": "arn:${AWS::Partition}:states:::aws-sdk:scheduler:createSchedule",
                "End": true
              },
              "ListSchedules": {
                "Type": "Task",
                "Parameters": {
                  "GroupName": "${ScheduleGroup}"
                },
                "Resource": "arn:${AWS::Partition}:states:::aws-sdk:scheduler:listSchedules",
                "Next": "Map"
              },
              "Map": {
                "Type": "Map",
                "ItemProcessor": {
                  "ProcessorConfig": {
                    "Mode": "INLINE"
                  },
                  "StartAt": "GetSchedule",
                  "States": {
                    "GetSchedule": {
                      "Type": "Task",
                      "End": true,
                      "Parameters": {
                        "GroupName.$": "$.GroupName",
                        "Name.$": "$.Name"
                      },
                      "Resource": "arn:${AWS::Partition}:states:::aws-sdk:scheduler:getSchedule",
                      "ResultSelector": {
                        "CreationDate.$": "$.CreationDate",
                        "Description.$": "$.Description",
                        "GroupName.$": "$.GroupName",
                        "Name.$": "$.Name",
                        "ScheduleExpression.$": "$.ScheduleExpression",
                        "ScheduleExpressionTimezone.$": "$.ScheduleExpressionTimezone"
                      }
                    }
                  }
                },
                "End": true,
                "ItemsPath": "$.Schedules"
              },
              "DeleteSchedule": {
                "Type": "Task",
                "Parameters": {
                  "GroupName": "${ScheduleGroup}",
                  "Name.$": "$.data.source.meetingName"
                },
                "Resource": "arn:${AWS::Partition}:states:::aws-sdk:scheduler:deleteSchedule",
                "End": true
              },
              "Pass": {
                "Type": "Pass",
                "End": true
              }
            }
          }
        - {
            ClusterArn: !GetAtt [Cluster, Arn],
            TargetECSRoleArn: !GetAtt [TargetECSRole, Arn],
            VPSecurityGroupId: !Ref VPSecurityGroupId,
            VPLaunchType: !Ref VPLaunchType,
          }

  UpdateLMASettingsWithStateMachine:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !Ref UpdateLMASettingsFunctionArn
      LCASettingsName: !Ref LMASettingsParameterName
      LCASettingsKeyValuePairs:
        LMAVirtualParticipantSchedulerStateMachine:
          !GetAtt [LMAVirtualParticipantSchedulerStateMachine, Arn]
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete

  ##########################################################################
  # Virtual Participant Scheduler
  ##########################################################################

  # EventBridge Schedule Group for Virtual Participants
  VPScheduleGroup:
    Type: AWS::Scheduler::ScheduleGroup
    Properties:
      Name: !Sub "${LMAStackName}-vp-schedules"

  # IAM Role for EventBridge Scheduler to execute ECS tasks
  VPSchedulerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - scheduler.amazonaws.com
                - events.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ECSTaskExecution
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ecs:RunTask
                Resource: 
                  - !Ref TaskDefinition
                  - !Sub "${TaskDefinition}:*"
              - Effect: Allow
                Action:
                  - ecs:TagResource
                Resource: "*"
                Condition:
                  StringEquals:
                    "ecs:CreateAction": "RunTask"
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: "*"
                Condition:
                  StringLike:
                    "iam:PassedToService": "ecs-tasks.amazonaws.com"

  # IAM Role for Virtual Participant Scheduler Lambda Function
  VirtualParticipantSchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: SchedulerLambdaPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - scheduler:CreateSchedule
                  - scheduler:DeleteSchedule
                  - scheduler:GetSchedule
                Resource: 
                  - !Sub "arn:aws:scheduler:${AWS::Region}:${AWS::AccountId}:schedule/${VPScheduleGroup}/*"
                  - !Sub "arn:aws:scheduler:${AWS::Region}:${AWS::AccountId}:schedule-group/${VPScheduleGroup}"
              - Effect: Allow
                Action:
                  - ecs:RunTask
                Resource: 
                  - !Ref TaskDefinition
                  - !Sub "${TaskDefinition}:*"
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt VPSchedulerExecutionRole.Arn
              - Effect: Allow
                Action:
                  - dynamodb:DescribeStream
                  - dynamodb:GetRecords
                  - dynamodb:GetShardIterator
                  - dynamodb:ListStreams
                Resource: !Ref VirtualParticipantTableStreamArn

  # Virtual Participant Scheduler Lambda Function
  VirtualParticipantSchedulerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${LMAStackName}-VPScheduler"
      Handler: index.lambda_handler
      Runtime: python3.12
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import os
          import json
          import boto3
          import logging
          from datetime import datetime, timezone
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          scheduler_client = boto3.client('scheduler')
          ecs_client = boto3.client('ecs')
          
          def lambda_handler(event, context):
              logger.info("Processing VP scheduler request")
              logger.info(f"Event: {json.dumps(event, default=str)}")
              
              try:
                  for record in event.get('Records', []):
                      event_name = record.get('eventName')
                      dynamodb_data = record.get('dynamodb', {})
                      
                      keys = dynamodb_data.get('Keys', {})
                      vp_id = keys.get('id', {}).get('S')
                      
                      if not vp_id:
                          logger.warning("No VP ID found in record, skipping")
                          continue
                          
                      logger.info(f"Processing {event_name} event for VP {vp_id}")
                      
                      if event_name == 'INSERT':
                          new_image = dynamodb_data.get('NewImage', {})
                          is_scheduled = new_image.get('isScheduled', {}).get('BOOL', False)
                          meeting_time = new_image.get('meetingTime', {}).get('N')
                          
                          if is_scheduled and meeting_time:
                              meeting_time_int = int(meeting_time)
                              current_time = int(datetime.now().timestamp())
                              
                              # Schedule for future execution
                              delay_seconds = 120  # 2 minutes before meeting
                              scheduled_time = datetime.fromtimestamp(meeting_time_int - delay_seconds, tz=timezone.utc)
                              
                              ecs_params = {
                                  'ClientToken': vp_id,
                                  'TaskDefinition': os.environ['TASK_DEFINITION_ARN'],
                                  'Cluster': os.environ['CLUSTER_ARN'],
                                  'LaunchType': 'FARGATE',
                                  'NetworkConfiguration': {
                                      'AwsvpcConfiguration': {
                                          'AssignPublicIp': 'DISABLED',
                                          'SecurityGroups': json.loads(os.environ['SECURITY_GROUPS']),
                                          'Subnets': json.loads(os.environ['SUBNETS']),
                                      }
                                  },
                                  'Overrides': {
                                      'ContainerOverrides': [{
                                          'Name': os.environ['CONTAINER_NAME'],
                                          'Environment': [
                                              {'Name': 'VIRTUAL_PARTICIPANT_ID', 'Value': vp_id},
                                              {'Name': 'MEETING_PLATFORM', 'Value': new_image.get('meetingPlatform', {}).get('S', '')},
                                              {'Name': 'MEETING_ID', 'Value': new_image.get('meetingId', {}).get('S', '')},
                                              {'Name': 'MEETING_PASSWORD', 'Value': new_image.get('meetingPassword', {}).get('S', '')},
                                              {'Name': 'MEETING_NAME', 'Value': new_image.get('meetingName', {}).get('S', '')},
                                              {'Name': 'MEETING_TIME', 'Value': str(meeting_time_int)},
                                              {'Name': 'LMA_USER', 'Value': new_image.get('owner', {}).get('S', '')},
                                              {'Name': 'GRAPHQL_ENDPOINT', 'Value': os.environ.get('GRAPHQL_ENDPOINT', '')},
                                              {'Name': 'CALL_DATA_STREAM_NAME', 'Value': os.environ.get('CALL_DATA_STREAM_NAME', '')},
                                              {'Name': 'RECORDINGS_BUCKET_NAME', 'Value': os.environ.get('RECORDINGS_BUCKET_NAME', '')},
                                              {'Name': 'VP_TASK_REGISTRY_TABLE_NAME', 'Value': os.environ.get('VP_TASK_REGISTRY_TABLE_NAME', '')},
                                          ]
                                      }]
                                  },
                                  'EnableExecuteCommand': False
                              }
                              
                              schedule_expression = f"at({scheduled_time.strftime('%Y-%m-%dT%H:%M:%S')})"
                              
                              response = scheduler_client.create_schedule(
                                  ActionAfterCompletion='DELETE',
                                  FlexibleTimeWindow={'Mode': 'OFF'},
                                  GroupName=os.environ['SCHEDULE_GROUP_NAME'],
                                  Name=vp_id,
                                  ScheduleExpression=schedule_expression,
                                  ScheduleExpressionTimezone='UTC',
                                  State='ENABLED',
                                  Target={
                                      'Arn': 'arn:aws:scheduler:::aws-sdk:ecs:runTask',
                                      'RoleArn': os.environ['SCHEDULER_ROLE_ARN'],
                                      'Input': json.dumps(ecs_params)
                                  }
                              )
                              
                              logger.info(f"Successfully scheduled VP {vp_id} with schedule ARN: {response.get('ScheduleArn')}")
                          else:
                              logger.info(f"VP {vp_id} is not scheduled, skipping")
                              
                      elif event_name == 'REMOVE':
                          try:
                              scheduler_client.delete_schedule(
                                  GroupName=os.environ['SCHEDULE_GROUP_NAME'],
                                  Name=vp_id
                              )
                              logger.info(f"Successfully unscheduled VP {vp_id}")
                          except scheduler_client.exceptions.ResourceNotFoundException:
                              logger.info(f"Schedule for VP {vp_id} not found (may have already been executed)")
                          except Exception as e:
                              logger.error(f"Error unscheduling VP {vp_id}: {str(e)}")
                  
                  return {'statusCode': 200, 'body': json.dumps({'message': 'Successfully processed VP scheduler events'})}
                  
              except Exception as e:
                  logger.error(f"Error processing VP scheduler events: {str(e)}")
                  return {'statusCode': 500, 'body': json.dumps({'error': str(e)})}
      Description: Virtual Participant Scheduler with EventBridge Scheduler integration
      MemorySize: 512
      Timeout: 300
      Role: !GetAtt VirtualParticipantSchedulerRole.Arn
      Environment:
        Variables:
          TASK_DEFINITION_ARN: !Ref TaskDefinition
          CLUSTER_ARN: !GetAtt Cluster.Arn
          SECURITY_GROUPS: !Sub '["${VPSecurityGroupId}"]'
          SUBNETS: !Sub '["${PrivateSubnet1}", "${PrivateSubnet2}"]'
          CONTAINER_NAME: "scribe"
          GRAPHQL_ENDPOINT: !Ref GraphQLEndpoint
          CALL_DATA_STREAM_NAME: !Ref CallDataStreamName
          RECORDINGS_BUCKET_NAME: !Ref S3BucketName
          VP_TASK_REGISTRY_TABLE_NAME: !Ref VPTaskRegistryTableName
          SCHEDULE_GROUP_NAME: !Ref VPScheduleGroup
          SCHEDULER_ROLE_ARN: !GetAtt VPSchedulerExecutionRole.Arn
  # DynamoDB Event Source Mapping for Scheduler Lambda
  VirtualParticipantSchedulerEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !Ref VirtualParticipantTableStreamArn
      FunctionName: !GetAtt VirtualParticipantSchedulerFunction.Arn
      StartingPosition: LATEST
      BatchSize: 10
      MaximumBatchingWindowInSeconds: 5

  VirtualParticipantSchedulerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/VPScheduler"
      RetentionInDays: !Ref CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

Outputs:
  StepFunctions:
    Description: Step Functions State Machine ARN
    Value: !Ref LMAVirtualParticipantSchedulerStateMachine
    Export:
      Name: !Sub "${AWS::StackName}-StateMachineArn"

  ClusterArn:
    Description: ECS Cluster ARN
    Value: !GetAtt Cluster.Arn
    Export:
      Name: !Sub "${AWS::StackName}-ClusterArn"

  TaskDefinitionArn:
    Description: Task Definition ARN
    Value: !Ref TaskDefinition
    Export:
      Name: !Sub "${AWS::StackName}-TaskDefinitionArn"

  ECRRepositoryUri:
    Description: ECR Repository URI
    Value: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ImageRepo}"
    Export:
      Name: !Sub "${AWS::StackName}-ECRRepositoryUri"

  VPScheduleGroupName:
    Description: Name of the EventBridge Schedule Group for Virtual Participants
    Value: !Ref VPScheduleGroup
    Export:
      Name: !Sub "${AWS::StackName}-VPScheduleGroupName"

  VPSchedulerExecutionRoleArn:
    Description: ARN of the EventBridge Scheduler execution role
    Value: !GetAtt VPSchedulerExecutionRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-VPSchedulerExecutionRoleArn"

  VirtualParticipantSchedulerFunctionArn:
    Description: ARN of the Virtual Participant Scheduler Lambda function
    Value: !GetAtt VirtualParticipantSchedulerFunction.Arn
    Export:
      Name: !Sub "${AWS::StackName}-VPSchedulerFunctionArn"
