# Copyright (c) 2025 Amazon.com
# This file is licensed under the MIT License.
# See the LICENSE file in the project root for full license information.

---
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31

Description: Amazon Transcribe Live Meeting Assist - AI Stack

Parameters:
  # Required
  LMAStackName:
    Type: String
    Description: LMA Stack Name

  CallDataStream:
    Type: String
    Description: >-
      The Name of Kinesis Data Stream to write the call data to.
  CallDataStreamArn:
    Type: String
    Description: >-
      The Arn of Kinesis Data Stream to write the call data to.


  LMASettingsParameterName:
    Type: String
    Description: LMA settings SSM Parameter store

  CustomerManagedEncryptionKeyArn:
    Type: String
    Description: ARN of the customer managed KMS key for encryption

  AudioRecordingExpirationInDays:
    Type: Number
    Description:
      "Number of days after which audio recordings will be deleted from
      the Recordings bucket."
    Default: 90

  CallAudioSource:
    Type: String
    AllowedValues:
      - Demo Asterisk PBX Server
      - Amazon Chime SDK Voice Connector (SIPREC)
      - Genesys Cloud Audiohook Web Socket
      - Amazon Connect Contact Lens

    Description: >
      Choose whether to automatically install a demo Asterisk PBX server for easy
      standalone testing, a
      Amazon Chime SDK Voice Connector to use for standards based SIPREC/NBR integration
      with your contact center,
      or a Web Socket interface to use for Audiohook integration with your Genesys
      Cloud CX contact center.

  S3BucketName:
    Type: String
    Default: ""
    Description: >
      Existing bucket where call recording files will be stored.
    # yamllint disable rule:line-length
    AllowedPattern: '( *|(?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$))'
    # yamllint enable rule:line-length

  AudioFilePrefix:
    Type: String
    Default: lma-audio-recordings/
    Description: >-
      The Amazon S3 prefix where the audio files will be saved (must end
      in "/")

  TranscriptFilePrefix:
    Type: String
    Default: lma-transcripts/
    Description: >-
      The Amazon S3 prefix where the transript files will be saved (must end in "/")

  TranscriptFileBucketName:
    Type: String
    Default: ""
    Description: >
      Existing bucket where transcript files will be stored.
    # yamllint disable rule:line-length
    AllowedPattern: '( *|(?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$))'
    # yamllint enable rule:line-length

  IsSentimentAnalysisEnabled:
    Type: String
    Default: "true"
    Description: >-
      Enable sentiment analysis
    AllowedValues:
      - "true"
      - "false"
  SentimentNegativeScoreThreshold:
    Type: Number
    Default: 0.9
    MinValue: 0
    MaxValue: 1
    Description: >-
      Minimum negative sentiment confidence required to declare a phrase as having
      negative sentiment, in the range 0-1.  Not applicable when using Contact Lens
      or Transcribe Call Analytics (as sentiment is pre-calculated).

  SentimentPositiveScoreThreshold:
    Type: Number
    Default: 0.4
    MinValue: 0
    MaxValue: 1
    Description: >-
      Minimum positive sentiment confidence required to declare a phrase as having
      positive sentiment, in the range 0-1.
      Not applicable when using Contact Lens or Transcribe Call Analytics (as sentiment
      is pre-calculated).
  ComprehendLanguageCode:
    Type: String
    Description: >-
      Language code to be used for Amazon Comprehend to detect sentiment. This
      should match the Amazon Transcribe language.
    Default: en
    AllowedValues:
      - en
      - es
      - fr
      - de
      - it
      - pt
      - ar
        # - hi
      - ja
      - ko
      - zh
        # - zh-TW

  TranscriptLambdaHookFunctionArn:
    Default: ""
    Type: String
    AllowedPattern: "^(|arn:aws:lambda:.*)$"
    Description: >
      (Optional) If present, the specified Lambda function is invoked by the LMA Call
      Event Processor Lambda function for each completed  (non-partial) transcript
      segment. The function can capture and/or modify the text of the transcript,
      for example to implement custom
      redaction logic, profanity filtering, or custom rules to highlight patterns
      in the transcript.

  TranscriptLambdaHookFunctionNonPartialOnly:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: >
      Specifies if Transcript Lambda Hook Function (if specified) is invoked for Non-Partial
      transcript segments only (true), or for
      both Partial and Non-Partial transcript segments (false).

  EndOfCallTranscriptSummary:
    Default: "BEDROCK"
    Type: String
    AllowedValues:
      - "LAMBDA"
      - "BEDROCK"

    Description: >
      Set to enable call summarization by a Large Language Model. Currently only BEDROCK
      and LAMBDA are supported.
      BEDROCK option requires you to choose one of the supported model IDs from the  provided
      list (BedrockModelId). The LAMBDA option requires you to provide a function
      ARN below.

  BedrockModelId:
    Default: "anthropic.claude-3-haiku-20240307-v1:0"
    Type: String
    AllowedValues:
      - "anthropic.claude-3-haiku-20240307-v1:0"
      - "anthropic.claude-3-sonnet-20240229-v1:0"
      - "anthropic.claude-3-5-sonnet-20240620-v1:0"
      - "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
      - "amazon.nova-micro-v1:0"
      - "amazon.nova-lite-v1:0"
      - "amazon.nova-pro-v1:0"
      - "us.amazon.nova-premier-v1:0"
      - "us.anthropic.claude-3-5-haiku-20241022-v1:0"
      - "us.anthropic.claude-3-7-sonnet-20250219-v1:0"
      - "us.anthropic.claude-sonnet-4-20250514-v1:0"
      - "us.anthropic.claude-opus-4-20250514-v1:0"
      - "us.anthropic.claude-opus-4-1-20250805-v1:0"
      - "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
      - "eu.anthropic.claude-3-5-sonnet-20240620-v1:0"
      - "apac.anthropic.claude-3-5-sonnet-20240620-v1:0"
      - "global.anthropic.claude-sonnet-4-20250514-v1:0"
      - "global.anthropic.claude-haiku-4-5-20251001-v1:0"
      - "global.anthropic.claude-sonnet-4-5-20250929-v1:0"
      - "global.amazon.nova-2-lite-v1:0"
      # - "global.amazon.nova-2-pro-v1:0"

    Description: >
      If EndOfCallTranscriptSummary is BEDROCK, then choose a model ID from the list
      of supported models. Includes Nova models (cost-effective), Claude 3.5/3.7 (advanced), 
      and Claude 4 (cutting-edge). Some models require inference profiles.
      Defaults to 'anthropic.claude-3-haiku-20240307-v1:0'

  EndOfCallLambdaHookFunctionArn:
    Default: ""
    Type: String
    AllowedPattern: "^(|arn:aws:lambda:.*)$"
    Description: >
      (Optional) If 'End Of Call Transcript Summary' is LAMBDA, provide ARN for a
      Lambda function. The specified Lambda function is invoked by the LMA Call Event
      Processor Lambda function  for end of call event. The function is passed en
      event with CallId as input.
      This function can implement custom logic that is relevant to end of call processing,
      for example, creating a call summary.

  StartOfCallLambdaHookFunctionArn:
    Default: ""
    Type: String
    AllowedPattern: "^(|arn:aws:lambda:.*)$"
    Description: >
      (Optional) The specified Lambda function is invoked by the LMA Call Event Processor
      Lambda function for beginning or start of  call event. This function can implement
      custom logic that is relevant to beginning of call processing, for example,
      retrieving
      call summary details logged into a case in a CRM.

  PostCallSummaryLambdaHookFunctionArn:
    Default: ""
    Type: String
    AllowedPattern: "^(|arn:aws:lambda:.*)$"
    Description: >
      (Optional) The specified Lambda function is invoked by the LMA Call Event Processor
      Lambda function after the call summary is processed.
      This function can implement custom logic that is relevant to post processing,
      for example, updating the call summary to a CRM system.

  UpdateLMASettingsFunctionArn:
    Type: String
    Description: Update LMA Settings Lambda function ARN

  CloudFrontPriceClass:
    Type: String
    Default: PriceClass_100
    Description: >-
      Specify the CloudFront price class. See https://aws.amazon.com/cloudfront/pricing/
      for a
      description of each price class.
    AllowedValues:
      - PriceClass_100
      - PriceClass_200
      - PriceClass_All
    ConstraintDescription: >-
      Allowed Price Classes PriceClass_100 PriceClass_200 and PriceClass_All

  CloudFrontAllowedGeos:
    Type: String
    Default: ""
    Description: >-
      Specify a comma separated list of two letter country codes (uppercase ISO 3166-1)
      that are
      allowed to access the web user interface via CloudFront. For example: US,CA.
      Leave empty if
      you do not want geo restrictions to be applied.
    AllowedPattern: "^(|[A-Z]{2}(,[A-Z]{2})*)$"
    ConstraintDescription: >-
      Comma separated list of uppercase two letter country codes or empty

  IsLexAgentAssistEnabled:
    Type: String
    Default: "false"
    Description: >-
      Enables the Lex Agent Assist feature.
    AllowedValues:
      - "true"
      - "false"
  IsLambdaAgentAssistEnabled:
    Type: String
    Default: "false"
    Description: >-
      Enables the Lambda Agent Assist feature. The AgentAssistExistingLambdaFunctionArn
      parameters should have values if this is set to 'true'
    AllowedValues:
      - "true"
      - "false"

  AgentAssistExistingLambdaFunctionArn:
    Default: ""
    Type: String
    AllowedPattern: "^(|arn:aws:lambda:.*)$"
    Description: >
      Used only if IsLambdaAgentAssistEnabled is set to "true".
      Provide the function ARN of an existing Lambda function to be used for Agent
      Assist."

  MeetingRecordExpirationInDays:
    Type: Number
    Default: 90
    Description: >-
      Number of days to retain meeting records. Meetings will be automatically deleted
      from LMA after this time.
      Specify partial days like 0.5 to retain meeting records for half a day.

  TranscriptionExpirationInDays:
    Type: Number
    Default: 90
    Description: >-
      Number of days to retain turn by turn meeting transcriptions.  Transcriptions
      will be automatically deleted from LMA after this time.
      Specify partial days like 0.5 to retain transcriptions for half a day.

  # NOTE: These parameters are dynamically updated during release
  BootstrapBucketBaseName:
    Type: String
    Default: aws-bigdata-blog
    Description: >-
      Base name of bootstrap S3 bucket. The region is appended to the bucket name.
      For example if
      you provide a base name `mybucket`, a bucket with a region suffix must exist
      in the region
      you are deploying (e.g. `mybucket-us-east-1`)
      The bucket contains pre-staged packaged templates and source artifacts
    # yamllint disable rule:line-length
    AllowedPattern: '(?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$)'
    # yamllint enable rule:line-length

  BootstrapS3Prefix:
    Type: String
    Default: artifacts/lca
    Description: >
      S3 prefix where the templates and source are stored under

  BootstrapVersion:
    Type: String
    Default: 0.2.11
    Description: >
      Artifacts version (semver). Used to point to a specific release in the S3
      bootstrap bucket

  AssistantWakePhraseRegEx:
    Type: String
    Default: "(OK|Okay)[.,! ]*[Aa]ssistant"
    Description: >
      A regular expression for the wake phrase that invokes the Meeting Assistant.
      Default is 'OK Assistant'.

  EnableVoiceToneAnalysis:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: >
      Whether or not to show the voice tone analysis panel in the UI

  LLMPromptTemplateTableName:
    Type: String
    Description:
      The DynamoDB table name where the default and custom summary prompt
      templates are stored.

  ChatButtonConfigTableName:
    Type: String
    Description:
      The DynamoDB table name where the default and custom STRANDS agent chat button
      configurations are stored.

  CloudWatchLogsExpirationInDays:
    Type: Number
    Default: 14
    Description: The number of days log events are kept in CloudWatch Logs.

  EnableAppSyncApiCache:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: >-
      Enable or disable the AppSync Api Cache.

  AppSyncApiCacheInstanceType:
    Type: String
    Default: SMALL
    AllowedValues:
      - SMALL
      - MEDIUM
      - LARGE
      - XLARGE
    Description: >-
      If you set the EnableAppSyncApiCache is true, choose a value that meets your workload requirements. 
      This parameter is ignored if the EnableAppSyncApiCache parameter is set to false (default behavior).

  UserPoolId:
    Type: String
    Description: >
      Cognito User Pool ID

  CognitoClientId:
    Type: String
    Description: Cognito User Pool Client ID

  AppIdentityPoolId:
    Type: String
    Description: Cognito Identity Pool used by the UI

  AllowedSignUpEmailDomain:
    Type: String
    Default: ""
    Description: >-
      Email address domain (example.com) or comma separated list of email domains  (example1.com,
      example2.com) allowed to signin and signup using the web UI.
      If left empty, signup via the web UI is disabled and users will have to be created
      using
      Cognito.
    AllowedPattern: '^(|([\w-]+\.)+[\w-]{2,6}(, *([\w-]+\.)+[\w-]{2,6})*)$'

  BedrockKnowledgeBaseID:
    Type: String
    Default: ""
    AllowedPattern: "^(|[0-9a-zA-Z]{10})$"
    Description: >
      Provide the *id* (not name) of an existing Bedrock Knowledge Base to be used for Agent Assist bot.

  EnableMCPServer:
    Type: String
    Default: "true"
    AllowedValues: ["true", "false"]
    Description: >-
      Enable MCP Server integration to allow external applications (Amazon Quick Suite,
      Claude Desktop, custom agentic systems) to access LMA meeting data via MCP protocol.

  MCPServerCallbackURLs:
    Type: String
    Default: ""
    Description: >-
      (Optional) Comma-separated list of additional OAuth callback URLs for custom MCP clients.

  CognitoUserPoolDomain:
    Type: String
    Default: ""
    Description: >-
      Cognito User Pool domain prefix for OAuth URLs (passed from COGNITOSTACK)

  LoggingBucketName:
    Type: String
    Description: Name of the logging bucket for S3 access logs

  VPC:
    Type: String
    Description: VPC ID for ALB deployment

  PublicSubnet1:
    Type: String
    Description: Public subnet 1 for ALB

  PublicSubnet2:
    Type: String
    Description: Public subnet 2 for ALB

  PermissionsBoundaryArn:
    Type: String
    Default: ""
    Description: >-
      (Optional) ARN of an existing IAM managed policy to use as permissions boundary for IAM roles.
      If provided, this policy will limit the maximum permissions that can be granted to IAM roles
      in this stack, providing an additional layer of security.

  EnableDataRetentionOnDelete:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: >-
      Enable data retention on stack deletion for compliance requirements.
      When true, DynamoDB tables will be retained. When false (default), all resources deleted.

  VPScheduleGroupName:
    Type: String
    Default: "LMA-VIRTUALPARTICIPANTSTACK-1ICEYE8S4JXFV-vp-schedules"
    Description: >-
      Name of the EventBridge Schedule Group for Virtual Participants from the VP stack.
      This should match the schedule group name created by the Virtual Participant stack.


Metadata:
  "AWS::CloudFormation::Interface":
    ParameterGroups:
      - Label:
          default: Amazon S3 Configuration
        Parameters:
          - S3BucketName
      - Label:
          default: Amazon CloudFront Configuration
        Parameters:
          - CloudFrontPriceClass
          - CloudFrontAllowedGeos
    ParameterLabels:
      S3BucketName:
        default: Call Audio Bucket Name
      CloudFrontPriceClass:
        default: CloudFront Price Class
      CloudFrontAllowedGeos:
        default: CloudFront Allowed Geographies
      IsSentimentAnalysisEnabled:
        default: Enable Sentiment Analysis
      ComprehendLanguageCode:
        default: Comprehend Sentiment Analysis Language Code
      TranscriptLambdaHookFunctionArn:
        default:
          Lambda Hook Function ARN for Custom Transcript Segment Processing
          (existing)
      TranscriptLambdaHookFunctionNonPartialOnly:
        default: Lambda Hook Function Mode Non-Partial only
      EndOfCallLambdaHookFunctionArn:
        default: Lambda Hook Function ARN for Custom End of Call Processing (existing)
      EndOfCallTranscriptSummary:
        default: End of Call Transcript Summary
      BedrockModelId:
        default: Bedrock supported LLM model ID
      StartOfCallLambdaHookFunctionArn:
        default: Lambda Hook Function ARN for Custom Start of Call Processing (existing)
      PostCallSummaryLambdaHookFunctionArn:
        default:
          Lambda Hook Function ARN for Custom Post Processing, after the Call
          Transcript Summary is processed (existing)

Conditions:
  ShouldRetainDataOnDelete: !Equals [!Ref EnableDataRetentionOnDelete, "true"]
  HasPermissionsBoundary: !Not [!Equals [!Ref PermissionsBoundaryArn, ""]]
  ShouldAllowSignUpEmailDomain:
    !Not [!Equals [!Ref AllowedSignUpEmailDomain, ""]]
  ShouldEnableGeoRestriction: !Not [!Equals [!Ref CloudFrontAllowedGeos, ""]]
  ShouldEnableMCPServer: !Equals [!Ref EnableMCPServer, "true"]
  HasCustomMCPServerCallbackURLs: !Not [!Equals [!Ref MCPServerCallbackURLs, ""]]
  ShouldEnableLambdaAgentAssist:
    !Equals [!Ref IsLambdaAgentAssistEnabled, "true"]
  ShouldEnableTranscriptLambdaHookFunction:
    !Not [!Equals [!Ref TranscriptLambdaHookFunctionArn, ""]]
  ShouldEnableStartOfCallLambdaHookFunction:
    !Not [!Equals [!Ref StartOfCallLambdaHookFunctionArn, ""]]
  ShouldEnablePostCallSummaryLambdaHookFunction:
    !Not [!Equals [!Ref PostCallSummaryLambdaHookFunctionArn, ""]]
  ShouldEnableEndOfCallLambdaHookFunction:
    !Equals [!Ref EndOfCallTranscriptSummary, "LAMBDA"]
  ShouldEnableBedrockSummarizer:
    !Equals [!Ref EndOfCallTranscriptSummary, "BEDROCK"]

  IsTranscriptSummaryEnabled: !Or
    - !Condition ShouldEnableEndOfCallLambdaHookFunction
    - !Condition ShouldEnableBedrockSummarizer

  ShouldEnableAppSyncApiCache: !Equals [!Ref EnableAppSyncApiCache, "true"]
  

Outputs:
  QuickSightManifestUrl:
    Description: S3 URL for QuickSight manifest file to import recordings bucket data
    Value: !Sub "https://${S3BucketName}.s3.${AWS::Region}.amazonaws.com/quicksight-recordingsbucket-manifest.json"
  CloudfrontEndpoint:
    Description: Endpoint for Cloudfront distribution
    Value: !Sub "https://${WebAppCloudFrontDistribution.DomainName}/"
  EventSourcingTableName:
    Description:
      The Name for the DynamoDB that is used to store transcriptions and
      events
    Value: !Ref EventSourcingTable
  EventSourcingTableArn:
    Description: >-
      The ARN of the DynamoDB table created to store events and the contact
      details used in this solution
    Value: !GetAtt EventSourcingTable.Arn
  CallEventProcessorFunctionRoleName:
    Description: The Name of the IAM role used by CallEventProcessorFunction
    Value: !Sub "${CallEventProcessorFunction}Role"
  SNSTopic:
    Description: The SNS topic name that LMA publishes category events to
    Value: !GetAtt CategorySNSTopic.TopicName
  FetchTranscriptArn:
    Description:
      The arn for a Lambda function that fetches a call transcript as a
      string
    Value: !GetAtt FetchTranscript.Arn
  CloudFrontDistributionId:
    Description: The ID of the CloudFront distribution for LMA's main web ui
    Value: !Ref WebAppCloudFrontDistribution
  WebAppBucket:
    Description: Name of S3 web app bucket
    Value: !Ref WebAppBucket
  CloudFrontDomainName:
    Description: The full domain name of the CloudFront distribution
    Value: !GetAtt WebAppCloudFrontDistribution.DomainName
  TranscriptSummaryFunctionArn:
    Description: Call Summarizer Lambda function ARN
    Value:
      !If [
        ShouldEnableBedrockSummarizer,
        !GetAtt BedrockSummaryLambda.Arn,
        !Ref EndOfCallLambdaHookFunctionArn,
      ]
  LocalUITestingEnv:
    Description: Copy to create .env file for local UI testing
    Value: !Sub >-
      REACT_APP_USER_POOL_ID=${UserPoolId}
      REACT_APP_USER_POOL_CLIENT_ID=${CognitoClientId}
      REACT_APP_IDENTITY_POOL_ID=${AppIdentityPoolId}
      REACT_APP_APPSYNC_GRAPHQL_URL=${AppSyncApiEncrypted.GraphQLUrl}
      REACT_APP_AWS_REGION=${AWS::Region}
      REACT_APP_SETTINGS_PARAMETER=${LMASettingsParameterName}
      REACT_APP_ENABLE_LEX_AGENT_ASSIST=true
  VPTaskRegistryTableName:
    Description: Name of the VPTaskRegistry DynamoDB table
    Value: !Ref VPTaskRegistry
  VirtualParticipantTableName:
    Description: Name of the VirtualParticipant DynamoDB table
    Value: !Ref VirtualParticipantTable
  VirtualParticipantTableStreamArn:
    Description: ARN of the VirtualParticipant DynamoDB table stream
    Value: !GetAtt VirtualParticipantTable.StreamArn
  AppSyncGraphQLUrl:
    Description: AppSync GraphQL endpoint URL
    Value: !GetAtt AppSyncApiEncrypted.GraphQLUrl
  AppSyncEventApiId:
    Description: AppSync Event API ID
    Value: !GetAtt AppSyncEventApi.ApiId
  AppSyncEventApiUrl:
    Description: AppSync Event API WebSocket URL for MCP commands
    Value: !GetAtt EventApiDns.WebSocketUrl
  AppSyncEventApiHttpUrl:
    Description: AppSync Event API HTTP URL for publishing
    Value: !GetAtt EventApiDns.HttpUrl
  VNCTargetGroupArn:
    Description: ARN of the VNC Target Group for Virtual Participant ECS tasks
    Value: !Ref VNCTargetGroup
  VNCALBSecurityGroupId:
    Description: Security Group ID for VNC ALB
    Value: !Ref ALBSecurityGroup
  VPSecurityGroupId:
    Description: Security Group ID for Virtual Participant ECS tasks
    Value: !Ref VPSecurityGroup
  VNCALBListenerArn:
    Description: ARN of the VNC ALB Listener for dynamic routing rules
    Value: !Ref VNCALBListener
    Export:
      Name: !Sub "${AWS::StackName}-VNCALBListenerArn"
  MCPServersTableName:
    Description: Name of the MCP Servers DynamoDB table
    Value: !Ref MCPServersTable
  MCPLayerBuildProjectName:
    Description: Name of the CodeBuild project for MCP layer building
    Value: !Ref MCPLayerBuildProject
  OAuthCallbackUrl:
    Description: OAuth callback URL for MCP server authorization (use this in your OAuth provider)
    Value: !Sub "https://${WebAppCloudFrontDistribution.DomainName}/#/oauth/callback"
  OAuthStateTableName:
    Description: Name of the OAuth State DynamoDB table
    Value: !Ref OAuthStateTable
  
  MCPServerEndpoint:
    Condition: ShouldEnableMCPServer
    Description: >-
      MCP Server endpoint for external applications to connect and access LMA meeting data.
      Use this URL with Amazon Quick Suite, Claude Desktop, or custom MCP clients.
    Value: !GetAtt MCPServerGateway.GatewayUrl
  
  MCPServerClientId:
    Condition: ShouldEnableMCPServer
    Description: >-
      Cognito Client ID for external applications to authenticate with LMA's MCP Server.
      Use with MCPServerClientSecret to obtain OAuth tokens.
    Value: !Ref MCPServerExternalAppClient
  
  MCPServerClientSecret:
    Condition: ShouldEnableMCPServer
    Description: >-
      Cognito Client Secret for external applications. STORE SECURELY!
      Use with MCPServerClientId to obtain OAuth tokens for MCP Server access.
    Value: !GetAtt MCPServerExternalAppClient.ClientSecret
  
  MCPServerUserPoolId:
    Condition: ShouldEnableMCPServer
    Description: Cognito User Pool ID for MCP Server authentication
    Value: !Ref UserPoolId
  
  MCPServerTokenURL:
    Condition: ShouldEnableMCPServer
    Description: >-
      OAuth token endpoint for obtaining access tokens to LMA's MCP Server.
      Example: curl -X POST <this-url> -d "grant_type=authorization_code&client_id=<MCPServerClientId>&client_secret=<MCPServerClientSecret>&code=<auth_code>&redirect_uri=<callback_url>"
    Value: !Sub "https://${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com/oauth2/token"
  
  MCPServerAuthorizationURL:
    Condition: ShouldEnableMCPServer
    Description: OAuth authorization endpoint for authorization code flow (browser-based authentication)
    Value: !Sub "https://${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com/oauth2/authorize"

Resources:
  EventSourcingTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: !If [ShouldRetainDataOnDelete, Retain, Delete]
    UpdateReplacePolicy: Retain
    Properties:
      AttributeDefinitions:
        # primary key attributes
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref CustomerManagedEncryptionKeyArn
      TimeToLiveSpecification:
        AttributeName: ExpiresAfter
        Enabled: true
      StreamSpecification:
        StreamViewType: NEW_IMAGE

  ##########################################################################
  # ParameterStore
  ##########################################################################

  UpdateSettingsValues:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !Ref UpdateLMASettingsFunctionArn
      LCASettingsName: !Ref LMASettingsParameterName
      LCASettingsKeyValuePairs:
        StackName: !Ref LMAStackName
        Version: !Ref BootstrapVersion
        BuildDateTime: "<BUILD_DATE_TIME>"
        # Add other existing settings that might be needed
        S3BucketName: !Ref S3BucketName
        AudioFilePrefix: !Ref AudioFilePrefix
        TranscriptFilePrefix: !Ref TranscriptFilePrefix

  ##########################################################################
  # CodeBuild
  ##########################################################################

  LMAUICodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource:
                  - !Sub "arn:aws:s3:::${BootstrapBucketBaseName}-${AWS::Region}"
                  - !Sub "arn:aws:s3:::${BootstrapBucketBaseName}-${AWS::Region}/${BootstrapS3Prefix}/*"
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:GetBucketAcl
                  - s3:GetBucketLocation
                  - s3:PutObject
                  - s3:ListBucket
              - Resource:
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*:*"
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
              - Resource: "*"
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !Sub "arn:aws:s3:::${WebAppBucket}/*"
              - Effect: Allow
                Action:
                  - cloudfront:CreateInvalidation
                Resource:
                  - !Sub "arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${WebAppCloudFrontDistribution}"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: >-
              ECR do not support resource-level permissions for GetAuthorizationToken
              and therefore
              cannot be specificed directly.

  LMAUICodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Description: !Sub >-
        Builds docker images and the website of stack: ${AWS::StackName}
      ServiceRole: !Ref LMAUICodeBuildServiceRole
      EncryptionKey: alias/aws/s3
      Artifacts:
        Type: NO_ARTIFACTS
      Source:
        # Makefile calculates and substitute code hash in the filename here during package build
        Location: !Sub "arn:aws:s3:::${BootstrapBucketBaseName}-${AWS::Region}/${BootstrapS3Prefix}/${BootstrapVersion}/src-hash.zip"
        Type: S3
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo ${SOURCE_CODE_LOCATION}
                - echo `ls -altr`
                - echo `pwd`
                - echo Installing NodeJS
                - n 18.19.1
                - npm install -g npm@10.2.4
                - echo Installing Web UI dependencies
                - cd source/ui
                - npm install
                - echo Performing token replacement for React build
                - cd $CODEBUILD_SRC_DIR
                - echo "Replacing VERSION_TOKEN with actual version in source files"
                - sed -i "s/<VERSION_TOKEN>/${IMAGE_TAG}/g" source/ui/src/components/common/constants.js
                - sed -i "s/<VERSION_TOKEN>/${IMAGE_TAG}/g" source/ui/package.json
                - sed -i "s/<VERSION_TOKEN>/${IMAGE_TAG}/g" source/ui/package-lock.json 2>/dev/null || true
                - sed -i "s/<VERSION_TOKEN>/${IMAGE_TAG}/g" VERSION
                - echo "Verification - checking replaced values:"
                - grep "LMA_VERSION" source/ui/src/components/common/constants.js || true
                - grep "version" source/ui/package.json | head -1 || true
            build:
              commands:
                - echo Build started on `date`
                - cd $CODEBUILD_SRC_DIR
                - cd source/ui
                - echo Building Web UI
                - npm run build
                - >
                  printf '{"RepositoryUri":"%s","ProjectName":"%s","ArtifactBucket":"%s"}'
                  $REPOSITORY_URI $PROJECT_NAME $ARTIFACT_BUCKET > build.json
            post_build:
              commands:
                - echo Build completed on `date`
                - echo Copying Web UI
                - find build -ls
                - aws s3 cp --recursive build s3://${WEBAPP_BUCKET}/
                - echo Invalidating CloudFront Distribution
                - >
                  aws cloudfront create-invalidation
                  --distribution-id "$CLOUDFRONT_DISTRIBUTION_ID" --paths '/*'
          artifacts:
            files:
              - build.json
      Environment:
        ComputeType: BUILD_GENERAL1_MEDIUM
        Image: aws/codebuild/amazonlinux2-x86_64-standard:5.0
        Type: LINUX_CONTAINER
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: IMAGE_TAG
            Value: !Ref BootstrapVersion
          - Name: SOURCE_CODE_LOCATION
            Value: !Sub "${BootstrapBucketBaseName}-${AWS::Region}/${BootstrapS3Prefix}/${BootstrapVersion}"
          - Name: WEBAPP_BUCKET
            Value: !Ref WebAppBucket
          - Name: CLOUDFRONT_DISTRIBUTION_ID
            Value: !Ref WebAppCloudFrontDistribution
            # These REACT_APP_ variables are used by the web ui in the
            # aws-exports.js Amplify config. The values are embedded in the
            # code at build time. See:
            # https://create-react-app.dev/docs/adding-custom-environment-variables/
          - Name: REACT_APP_SETTINGS_PARAMETER
            Value: !Ref LMASettingsParameterName
          - Name: REACT_APP_USER_POOL_ID
            Value: !Ref UserPoolId
          - Name: REACT_APP_USER_POOL_CLIENT_ID
            Value: !Ref CognitoClientId
          - Name: REACT_APP_IDENTITY_POOL_ID
            Value: !Ref AppIdentityPoolId
          - Name: REACT_APP_APPSYNC_GRAPHQL_URL
            Value: !GetAtt AppSyncApiEncrypted.GraphQLUrl
          - Name: REACT_APP_AWS_REGION
            Value: !Ref AWS::Region
          - Name: REACT_APP_SHOULD_HIDE_SIGN_UP
            Value: !If
              - ShouldAllowSignUpEmailDomain
              - "false"
              - "true"
          - Name: REACT_APP_ENABLE_AGENT_ASSIST
            Value: !If
              - ShouldEnableLambdaAgentAssist
              - "true"
              - !Ref IsLexAgentAssistEnabled
          - Name: REACT_APP_AGENT_ASSIST_MODE
            Value: !If
              - ShouldEnableLambdaAgentAssist
              - "LAMBDA"
              - "LEX"
          - Name: REACT_APP_CLOUDFRONT_DOMAIN
            Value: !Sub "https://${WebAppCloudFrontDistribution.DomainName}/"
  # CodeBuild project for building MCP servers Lambda layer
  MCPLayerBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub "${AWS::StackName}-MCP-Layer-Builder"
      Description: Builds Lambda layer with installed MCP servers
      ServiceRole: !Ref MCPLayerBuildRole
      EncryptionKey: alias/aws/s3
      Artifacts:
        Type: NO_ARTIFACTS
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "MCP Layer Builder"
                - yum install -y jq zip python3.12 python3.12-pip
                - python3.12 --version
                - python3.12 -m pip --version
            build:
              commands:
                - echo "Querying DynamoDB for installed MCP servers"
                - aws dynamodb query --table-name "$MCP_SERVERS_TABLE" --key-condition-expression "AccountId = :accountId" --expression-attribute-values '{":accountId":{"S":"'$AWS_ACCOUNT_ID'"}}' --output json > /tmp/servers.json
                - SERVER_COUNT=$(jq '.Items | length' /tmp/servers.json)
                - echo "Found $SERVER_COUNT MCP servers"
                - echo "Building Lambda layer with Python dependencies"
                - mkdir -p layer/python && cd layer/python
                - echo "Step 1 - Installing base Python dependencies (required for Lambda function)"
                - echo "strands-agents>=0.1.0" > requirements.txt
                - echo "boto3>=1.28.0" >> requirements.txt
                - echo "botocore>=1.31.0" >> requirements.txt
                - echo "tavily-python>=0.3.0" >> requirements.txt
                - echo "gql>=3.4.0" >> requirements.txt
                - echo "requests>=2.31.0" >> requirements.txt
                - echo "requests-toolbelt>=0.10.0" >> requirements.txt
                - echo "mcp>=1.0.0" >> requirements.txt
                - cat requirements.txt
                - python3.12 -m pip install -r requirements.txt -t . --no-cache-dir --upgrade
                - echo "Base dependencies installed successfully"
                - |
                  if [ "$SERVER_COUNT" -gt "0" ]; then
                    echo "Step 2 - Installing MCP server packages from DynamoDB";
                    
                    # Filter out HTTP servers (they don't need package installation)
                    jq -r '.Items[] | select(.PackageType.S != "streamable-http" and .PackageType.S != null) | .NpmPackage.S' /tmp/servers.json > mcp-servers.txt;
                    
                    # Also include servers without PackageType (backward compatibility - assume pypi)
                    jq -r '.Items[] | select(.PackageType.S == null) | .NpmPackage.S' /tmp/servers.json >> mcp-servers.txt;
                    
                    PACKAGE_COUNT=$(wc -l < mcp-servers.txt | tr -d ' ')
                    echo "Found $PACKAGE_COUNT package-based servers to install";
                    
                    if [ "$PACKAGE_COUNT" -gt "0" ]; then
                      echo "MCP packages to install:";
                      cat mcp-servers.txt;
                      while IFS= read -r package; do
                        if [ -n "$package" ]; then
                          echo "Attempting to install: $package";
                          if python3.12 -m pip install "$package" -t . --no-cache-dir 2>&1; then
                            echo "Successfully installed $package";
                          else
                            echo "WARNING: Failed to install $package (package may not exist in PyPI)";
                            echo "Continuing with build...";
                          fi;
                        fi;
                      done < mcp-servers.txt;
                    else
                      echo "No package-based servers to install (all servers are HTTP-based)";
                    fi;
                  else
                    echo "Step 2 - No MCP servers configured, skipping MCP package installation";
                  fi
                - cd ../..
                - echo "Packaging Lambda layer"
                - cd layer && zip -r ../mcp-layer.zip . -q && cd ..
                - LAYER_SIZE_BYTES=$(stat -c%s mcp-layer.zip)
                - LAYER_SIZE_MB=$((LAYER_SIZE_BYTES / 1024 / 1024))
                - echo "Layer size is ${LAYER_SIZE_MB}MB"
                - |
                  if [ "$LAYER_SIZE_BYTES" -gt "50000000" ]; then
                    echo "Layer exceeds 70MB limit - uploading to S3 first";
                    echo "Using S3 bucket: $S3_BUCKET";
                    S3_KEY="mcp-layers/$STACK_NAME-mcp-servers-$(date +%s).zip";
                    echo "Uploading to s3://$S3_BUCKET/$S3_KEY";
                    aws s3 cp mcp-layer.zip "s3://$S3_BUCKET/$S3_KEY";
                    echo "Publishing layer from S3";
                    if aws lambda publish-layer-version --layer-name "$STACK_NAME-mcp-servers" --description "MCP servers and dependencies" --content "S3Bucket=$S3_BUCKET,S3Key=$S3_KEY" --compatible-runtimes python3.12 --query 'Version' --output text > /tmp/version.txt 2>&1; then
                      echo "Layer published successfully";
                    else
                      echo "ERROR: Layer unzipped size exceeds Lambda's 250MB limit";
                      echo "This MCP server has too many dependencies for Lambda layers";
                      echo "Marking server as FAILED in DynamoDB";
                      if [ -n "$SERVER_ID" ]; then
                        aws dynamodb update-item --table-name "$MCP_SERVERS_TABLE" --key "{\"AccountId\":{\"S\":\"$AWS_ACCOUNT_ID\"},\"ServerId\":{\"S\":\"$SERVER_ID\"}}" --update-expression "SET #status = :status, ErrorMessage = :error" --expression-attribute-names '{"#status":"Status"}' --expression-attribute-values "{\":status\":{\"S\":\"FAILED\"},\":error\":{\"S\":\"Layer too large: unzipped size exceeds 250MB limit\"}}";
                      fi;
                      exit 1;
                    fi;
                  else
                    echo "Layer size OK - publishing directly";
                    aws lambda publish-layer-version --layer-name "$STACK_NAME-mcp-servers" --description "MCP servers and dependencies" --zip-file fileb://mcp-layer.zip --compatible-runtimes python3.12 --query 'Version' --output text > /tmp/version.txt;
                  fi
                - echo "Published layer version $(cat /tmp/version.txt)"
                - FUNCTION_NAME=$(aws lambda list-functions --query "Functions[?contains(FunctionName, 'MeetingAssist')].FunctionName" --output text)
                - echo "Found Lambda function $FUNCTION_NAME"
                - aws lambda get-function-configuration --function-name "$FUNCTION_NAME" --query 'Layers[].LayerArn' --output json > /tmp/current.json
                - jq -r --arg layer "arn:aws:lambda:$AWS_DEFAULT_REGION:$AWS_ACCOUNT_ID:layer:$STACK_NAME-mcp-servers:$(cat /tmp/version.txt)" 'map(select(. | contains("mcp-servers") | not)) + [$layer] | join(" ")' /tmp/current.json > /tmp/layers.txt
                - aws lambda update-function-configuration --function-name "$FUNCTION_NAME" --layers $(cat /tmp/layers.txt)
                - echo "Lambda function updated with new layer"
                - |
                  if [ "$ACTION" = "INSTALL_MCP_SERVER" ] && [ -n "$SERVER_ID" ]; then
                    echo "Updating DynamoDB server status to ACTIVE";
                    aws dynamodb update-item --table-name "$MCP_SERVERS_TABLE" --key "{\"AccountId\":{\"S\":\"$AWS_ACCOUNT_ID\"},\"ServerId\":{\"S\":\"$SERVER_ID\"}}" --update-expression "SET #status = :status, UpdatedAt = :updated" --expression-attribute-names '{"#status":"Status"}' --expression-attribute-values "{\":status\":{\"S\":\"ACTIVE\"},\":updated\":{\"S\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}}";
                    echo "Server status updated to ACTIVE";
                  fi
      Environment:
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/amazonlinux2-x86_64-standard:5.0
        Type: LINUX_CONTAINER
        EnvironmentVariables:
          - Name: STACK_NAME
            Value: !Ref AWS::StackName
          - Name: MCP_SERVERS_TABLE
            Value: !Ref MCPServersTable
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: S3_BUCKET
            Value: !Sub "${BootstrapBucketBaseName}-${AWS::Region}"
      TimeoutInMinutes: 15

  MCPLayerBuildRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: codebuild.amazonaws.com
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: MCPLayerBuild
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*"
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:UpdateItem
                Resource: !GetAtt MCPServersTable.Arn
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource: !Ref CustomerManagedEncryptionKeyArn
              - Effect: Allow
                Action:
                  - lambda:ListFunctions
                Resource: "*"
              - Effect: Allow
                Action:
                  - lambda:PublishLayerVersion
                  - lambda:GetLayerVersion
                  - lambda:GetFunctionConfiguration
                  - lambda:UpdateFunctionConfiguration
                Resource:
                  - !Sub
                    - "arn:aws:lambda:${Region}:${AccountId}:layer:${StackName}-mcp-servers"
                    - Region: !Ref AWS::Region
                      AccountId: !Ref AWS::AccountId
                      StackName: !Ref AWS::StackName
                  - !Sub
                    - "arn:aws:lambda:${Region}:${AccountId}:layer:${StackName}-mcp-servers:*"
                    - Region: !Ref AWS::Region
                      AccountId: !Ref AWS::AccountId
                      StackName: !Ref AWS::StackName
                  - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:STRANDS-${LMAStackName}-*"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub "arn:aws:s3:::${BootstrapBucketBaseName}-${AWS::Region}/mcp-layers/*"

  LambdaCodeBuildStartBuildExecutionRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "CodeBuild integration requires broad CloudWatch Logs access for log group creation and management"
    # checkov:skip=CKV_AWS_111: "CodeBuild integration requires broad CloudWatch Logs access for log group creation and management"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !GetAtt LMAUICodeBuildProject.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
          # Used by custom resource helper poller
          # https://github.com/aws-cloudformation/custom-resource-helper
        - PolicyName: CustomResourcePoller
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - events:PutRule
                  - events:DeleteRule
                  - events:PutTargets
                  - events:RemoveTargets
                Resource:
                  - !Sub "arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*"
              - Effect: Allow
                Action:
                  - lambda:AddPermission
                  - lambda:RemovePermission
                Resource:
                  - !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*"

  CodeBuildRun:
    Type: Custom::CodeBuildRun
    Properties:
      ServiceToken: !GetAtt LambdaCodeBuildStartBuild.Arn
      BuildProjectName: !Ref LMAUICodeBuildProject
      IsLexAgentAssistEnabled: !Ref IsLexAgentAssistEnabled
      EnableVoiceToneAnalysis: !Ref EnableVoiceToneAnalysis
      IsSentimentAnalysisEnabled: !Ref IsSentimentAnalysisEnabled
      LMASettingsParameterName: !Ref LMASettingsParameterName
      # Makefile calculates and substitute code hash in the filename here during package build
      # to force codebuild to rerun when source code changes, and to correctly roll back to
      # previous version if build fails.
      CodeLocation: !Sub "arn:aws:s3:::${BootstrapBucketBaseName}-${AWS::Region}/${BootstrapS3Prefix}/${BootstrapVersion}/src-hash.zip"

  LambdaCodeBuildStartBuild:
    Type: AWS::Serverless::Function
    Properties:
      Role: !GetAtt LambdaCodeBuildStartBuildExecutionRole.Arn
      Runtime: python3.12
      Timeout: 60
      MemorySize: 128
      Handler: lambda_start_codebuild.handler
      CodeUri: ../source/lambda_functions/start_codebuild
      Description: This AWS Lambda Function kicks off a code build job.
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/LambdaCodeBuildStartBuild
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    DependsOn:
      - LambdaCodeBuildStartBuildLogGroup

  LambdaCodeBuildStartBuildLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/LambdaCodeBuildStartBuild
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  DataStreamConsumer:
    Type: AWS::Kinesis::StreamConsumer
    Properties:
      StreamARN: !Ref CallDataStreamArn
      ConsumerName: DataStreamConsumer


  FetchTranscript:
    Type: AWS::Serverless::Function
    Properties:
      Role: !GetAtt LambdaFetchTranscriptExecutionRole.Arn
      Runtime: python3.12
      Environment:
        Variables:
          LCA_CALL_EVENTS_TABLE: !Ref EventSourcingTable
      Timeout: 60
      MemorySize: 128
      Handler: index.lambda_handler
      CodeUri: ../source/lambda_functions/fetch_transcript
      Description: This AWS Lambda Function fetches the call transcript for processing.
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/FetchTranscript
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - FetchTranscriptLogGroup

  FetchTranscriptLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/FetchTranscript
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  LambdaFetchTranscriptExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: Fetch Transcript Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-FetchTranscript
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: 
                  - dynamodb:Query
                  - dynamodb:GetItem
                Resource: !GetAtt EventSourcingTable.Arn
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource: !Ref CustomerManagedEncryptionKeyArn

  BedrockSummaryLambda:
    Type: AWS::Serverless::Function
    Condition: ShouldEnableBedrockSummarizer
    Properties:
      Role: !GetAtt BedrockSummaryLambdaExecutionRole.Arn
      Runtime: python3.12
      Environment:
        Variables:
          BEDROCK_MODEL_ID: !Ref BedrockModelId
          FETCH_TRANSCRIPT_LAMBDA_ARN: !GetAtt FetchTranscript.Arn
          TOKEN_COUNT: "0"
          PROCESS_TRANSCRIPT: "True"
          LLM_PROMPT_TEMPLATE_TABLE_NAME: !Ref LLMPromptTemplateTableName
          S3_BUCKET_NAME: !Ref S3BucketName
          S3_PREFIX: !Ref TranscriptFilePrefix
      Timeout: 900
      MemorySize: 512
      Handler: index.handler
      CodeUri: ../source/lambda_functions/bedrock_summary_lambda
      Description:
        This AWS Lambda Function runs a transcript summary inference on
        the call transcript using Bedrock API
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/BedrockSummaryLambda
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - BedrockSummaryLambdaLogGroup

  BedrockSummaryLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/BedrockSummaryLambda
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  BedrockSummaryLambdaExecutionRole:
    Type: AWS::IAM::Role
    Condition: ShouldEnableBedrockSummarizer
    Properties:
      Description: Bedrock Summary Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-Bedrock-Fetch-Transcript
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "lambda:InvokeFunction"
                Resource: !GetAtt FetchTranscript.Arn
              - Effect: Allow
                Action:
                  - "dynamodb:GetItem"
                Resource:
                  - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${LLMPromptTemplateTableName}"
        - PolicyName: !Sub ${AWS::StackName}-BedrockSummary
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "bedrock:InvokeModel"
                Resource:
                  - !Sub "arn:${AWS::Partition}:bedrock:*::foundation-model/*"
                  - !Sub "arn:${AWS::Partition}:bedrock:*:${AWS::AccountId}:custom-model/*"
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*"
              - Effect: Allow
                Action:
                  - "bedrock:GetInferenceProfile"
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*"
        - PolicyName: !Sub ${AWS::StackName}-S3
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "s3:PutObject"
                Resource:
                  - !Sub "arn:aws:s3:::${S3BucketName}"
                  - !Sub "arn:aws:s3:::${S3BucketName}/*"

  AsyncAgentAssistOrchestrator:
    Type: AWS::Serverless::Function
    Properties:
      Role: !GetAtt AsyncAgentAssistOrchestratorExecutionRole.Arn
      Runtime: python3.12
      Environment:
        Variables:
          CALL_DATA_STREAM_NAME: !Ref CallDataStream
          LEX_BOT_ID: "Pending AgentAssistSetup"
          LEX_BOT_ALIAS_ID: "Pending AgentAssistSetup"
          LEX_BOT_LOCALE_ID: "Pending AgentAssistSetup"
          # Lex Agent Assist
          IS_LEX_AGENT_ASSIST_ENABLED: !Ref IsLexAgentAssistEnabled
          # Lambda Agent Assist
          IS_LAMBDA_AGENT_ASSIST_ENABLED: !Ref IsLambdaAgentAssistEnabled
          LAMBDA_AGENT_ASSIST_FUNCTION_ARN: !Ref AgentAssistExistingLambdaFunctionArn
          DYNAMODB_TABLE_NAME: !Ref EventSourcingTable
          EVENT_API_HTTP_URL: !GetAtt EventApiDns.HttpUrl
      Timeout: 60
      MemorySize: 128
      Handler: lambda_function.handler
      Layers:
        - !Ref TranscriptEnrichmentPythonLayer
      CodeUri: ../source/lambda_functions/async_agent_assist_orchestrator
      Description: This AWS Lambda Function orchestrates agent assist processing.
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/AsyncAgentAssistOrchestrator
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - AsyncAgentAssistOrchestratorLogGroup

  StrandsChatInterfaceFunction:
    Type: AWS::Serverless::Function
    Properties:
      Role: !GetAtt StrandsChatInterfaceFunctionExecutionRole.Arn
      Runtime: python3.12
      SnapStart:
        ApplyOn: PublishedVersions
      Environment:
        Variables:
          ASYNC_AGENT_ASSIST_ORCHESTRATOR_ARN: !GetAtt AsyncAgentAssistOrchestrator.Arn
      Timeout: 30
      MemorySize: 128
      Handler: lambda_function.lambda_handler
      CodeUri: ../source/lambda_functions/strands_chat_interface
      Description: This AWS Lambda Function handles STRANDS chat interface messages.
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/StrandsChatInterfaceFunction
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for chat interface function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like function ARNs"
    DependsOn:
      - StrandsChatInterfaceFunctionLogGroup

  StrandsChatInterfaceFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/StrandsChatInterfaceFunction
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  StrandsChatInterfaceFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: STRANDS Chat Interface Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-StrandsChatInterface
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt AsyncAgentAssistOrchestrator.Arn

  AsyncAgentAssistOrchestratorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/AsyncAgentAssistOrchestrator
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  AsyncAgentAssistOrchestratorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: Async Agent Assist Orchestrator Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-AsyncAgentAssist
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: kinesis:PutRecord
                Resource: !Ref CallDataStreamArn
              - Effect: Allow
                Action:
                  - lex:RecognizeText
                Resource: "*"
              - Effect: Allow
                Action:
                  - appsync:GraphQL
                Resource:
                  - !Sub "${AppSyncApiEncrypted.Arn}/*"
              - Effect: Allow
                Action:
                  - appsync:EventConnect
                  - appsync:EventSubscribe
                  - appsync:EventPublish
                Resource:
                  - !Sub "arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/${AppSyncEventApi.ApiId}/*"
              - !If
                - ShouldEnableLambdaAgentAssist
                - Effect: Allow
                  Action:
                    - lambda:InvokeFunction
                  Resource:
                    - !Sub
                      - "arn:aws:lambda:${Region}:${AccountId}:function:STRANDS-${StackName}-*"
                      - Region: !Ref AWS::Region
                        AccountId: !Ref AWS::AccountId
                        StackName: !Ref LMAStackName
                    - !Sub "${AgentAssistExistingLambdaFunctionArn}"
                - Ref: AWS::NoValue

  AsyncTranscriptSummaryOrchestrator:
    Type: AWS::Serverless::Function
    Properties:
      Role: !GetAtt AsyncTranscriptSummaryOrchestratorExecutionRole.Arn
      Runtime: python3.12
      Environment:
        Variables:
          TRANSCRIPT_SUMMARY_FUNCTION_ARN:
            !If [
              ShouldEnableBedrockSummarizer,
              !GetAtt BedrockSummaryLambda.Arn,
              !Ref EndOfCallLambdaHookFunctionArn,
            ]
          CALL_DATA_STREAM_NAME: !Ref CallDataStream
          BOTO_READ_TIMEOUT: 60
      Timeout: 240
      MemorySize: 128
      Handler: lambda_function.handler
      Layers:
        - !Ref TranscriptEnrichmentPythonLayer
      CodeUri: ../source/lambda_functions/async_transcript_summary_orchestrator
      Description: This AWS Lambda Function orchestrates call summary processing processing.
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/AsyncTranscriptSummaryOrchestrator
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - AsyncTranscriptSummaryOrchestratorLogGroup

  AsyncTranscriptSummaryOrchestratorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/AsyncTranscriptSummaryOrchestrator
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  AsyncTranscriptSummaryOrchestratorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: Async Transcript Summary Orchetrator Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-AsyncTranscriptSummary
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: kinesis:PutRecord
                Resource: !Ref CallDataStreamArn
              - !If
                - ShouldEnableEndOfCallLambdaHookFunction
                - Effect: Allow
                  Action:
                    - lambda:InvokeFunction
                  Resource: !Sub "${EndOfCallLambdaHookFunctionArn}"
                - Ref: AWS::NoValue
              - !If
                - ShouldEnableBedrockSummarizer
                - Effect: Allow
                  Action:
                    - lambda:InvokeFunction
                  Resource:
                    - !GetAtt BedrockSummaryLambda.Arn
                - Ref: AWS::NoValue


  ##########################################################################
  # SNS Topic for Category Event Notifications
  ##########################################################################
  CategorySNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: !Ref CustomerManagedEncryptionKeyArn

  ##########################################################################
  # Call Event Processor
  ##########################################################################
  CallEventProcessorFunction:
    Type: AWS::Serverless::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
          - id: W11
            reason: comprehend does not support resource-level permissions
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    Properties:
      Architectures:
        - arm64
      CodeUri: ../source/lambda_functions/call_event_processor
      Description: !Sub >-
        Call Event and Transcript Processor for stack: ${AWS::StackName}
      Events:
        TranscriptKds:
          Type: Kinesis
          Properties:
            # https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-function-kinesis.html#sam-property-function-kinesis--examples
            BatchSize: 200
            BisectBatchOnFunctionError: true
            # TODO Add SQS queue for discarded records
            # DestinationConfig:
            Enabled: true
            MaximumRetryAttempts: 2
            MaximumBatchingWindowInSeconds: 0
            ParallelizationFactor: 10
            # XXX MaximumRecordAgeInSeconds: 900
            StartingPosition: LATEST
            Stream: !GetAtt DataStreamConsumer.ConsumerARN
            # Tumbling Window is used for aggregations over different invocations
            # https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows
            TumblingWindowInSeconds: 0
      Handler: lambda_function.handler
      Layers:
        - !Ref TranscriptEnrichmentPythonLayer
      MemorySize: 3000
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref EventSourcingTable
        - Statement:
            - Effect: Allow
              Action:
                - sns:Publish
              Resource: !Ref CategorySNSTopic
            - Effect: Allow
              Action:
                - ssm:GetParameter
              Resource: !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${LMASettingsParameterName}"
            - Effect: Allow
              Action:
                - appsync:GraphQL
              Resource:
                # XXX specific mutation - addEnrichment
                - !Sub "${AppSyncApiEncrypted.Arn}/types/Mutation/*"
                - !Sub "${AppSyncApiEncrypted.Arn}/types/Query/fields/__schema"
                - !Sub "${AppSyncApiEncrypted.Arn}/types/Query/fields/getCall"
                - !Sub "${AppSyncApiEncrypted.Arn}/types/Query/*"
            - Effect: Allow
              Action:
                - comprehend:DetectSentiment
              Resource: "*"
            - Effect: Allow
              Action:
                - events:PutEvents
              Resource:
                - !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:event-bus/default"
            - !If
              - ShouldEnableTranscriptLambdaHookFunction
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !Sub "${TranscriptLambdaHookFunctionArn}"
              - Ref: AWS::NoValue
            - !If
              - ShouldEnableStartOfCallLambdaHookFunction
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !Sub "${StartOfCallLambdaHookFunctionArn}"
              - Ref: AWS::NoValue
            - !If
              - ShouldEnablePostCallSummaryLambdaHookFunction
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !Sub "${PostCallSummaryLambdaHookFunctionArn}"
              - Ref: AWS::NoValue
            - !If
              - IsTranscriptSummaryEnabled
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt AsyncTranscriptSummaryOrchestrator.Arn
              - Ref: AWS::NoValue
            - Effect: Allow
              Action:
                - lambda:InvokeFunction
              Resource: !GetAtt AsyncAgentAssistOrchestrator.Arn
      Runtime: python3.12
      Timeout: 900
      Environment:
        Variables:
          # XXX add log level parameter or map
          LOG_LEVEL: DEBUG
          POWERTOOLS_METRICS_NAMESPACE: !Sub "TranscriptProcessor-${AWS::StackName}"
          POWERTOOLS_SERVICE_NAME: TranscriptProcessor
          # XXX add trace parameter or map
          POWERTOOLS_TRACE_DISABLED: false
          APPSYNC_GRAPHQL_URL: !GetAtt AppSyncApiEncrypted.GraphQLUrl
          STATE_DYNAMODB_TABLE_NAME: !Ref EventSourcingTable
          COMPREHEND_LANGUAGE_CODE: !Ref ComprehendLanguageCode
          IS_SENTIMENT_ANALYSIS_ENABLED: !Ref IsSentimentAnalysisEnabled
          SENTIMENT_NEGATIVE_THRESHOLD: !Ref SentimentNegativeScoreThreshold
          SENTIMENT_POSITIVE_THRESHOLD: !Ref SentimentPositiveScoreThreshold
          CALL_AUDIO_SOURCE: !Ref CallAudioSource
          # Lex Agent Assist
          IS_LEX_AGENT_ASSIST_ENABLED: !Ref IsLexAgentAssistEnabled
          # Lambda Agent Assist
          IS_LAMBDA_AGENT_ASSIST_ENABLED: !Ref IsLambdaAgentAssistEnabled
          MEETING_RECORD_EXPIRATION_IN_DAYS: !Ref MeetingRecordExpirationInDays
          TRANSCRIPTION_RECORD_EXPIRATION_IN_DAYS: !Ref TranscriptionExpirationInDays
          TRANSCRIPT_LAMBDA_HOOK_FUNCTION_ARN: !Ref TranscriptLambdaHookFunctionArn
          START_OF_CALL_LAMBDA_HOOK_FUNCTION_ARN: !Ref StartOfCallLambdaHookFunctionArn
          POST_CALL_SUMMARY_LAMBDA_HOOK_FUNCTION_ARN: !Ref PostCallSummaryLambdaHookFunctionArn
          TRANSCRIPT_LAMBDA_HOOK_FUNCTION_NONPARTIAL_ONLY: !Ref TranscriptLambdaHookFunctionNonPartialOnly
          IS_TRANSCRIPT_SUMMARY_ENABLED:
            !If [IsTranscriptSummaryEnabled, "true", "false"]
          ASYNC_TRANSCRIPT_SUMMARY_ORCHESTRATOR_ARN: !GetAtt AsyncTranscriptSummaryOrchestrator.Arn
          ASYNC_AGENT_ASSIST_ORCHESTRATOR_ARN: !GetAtt AsyncAgentAssistOrchestrator.Arn
          CALL_DATA_STREAM_NAME: !Ref CallDataStream
          SNS_TOPIC_ARN: !Ref CategorySNSTopic
          PARAMETER_STORE_NAME: !Ref LMASettingsParameterName
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/CallEventProcessorFunction
    DependsOn:
      - CallEventProcessorFunctionLogGroup

  CallEventProcessorFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/CallEventProcessorFunction
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  ##########################################################################
  # Transcript Enrichment Lambda Layers
  ##########################################################################
  TranscriptEnrichmentPythonLayer:
    Type: AWS::Serverless::LayerVersion
    Metadata:
      BuildMethod: python3.12
    Properties:
      Description: !Sub "Transcript Enrichment Python Layer for stack: ${AWS::StackName}"
      ContentUri: ../source/lambda_layers/transcript_enrichment_layer
      CompatibleArchitectures:
        - arm64
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Delete

  ##########################################################################
  # AppSync
  ##########################################################################

  AppSyncCwlRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com

  AppSyncDynamoDbRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com
      Policies:
        - PolicyName: dynamoDB
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                Resource: !GetAtt EventSourcingTable.Arn
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource: !Ref CustomerManagedEncryptionKeyArn

  QueryKnowledgeBaseResolverFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt QueryKnowledgeBaseResolverFunctionExecutionRole.Arn
      Runtime: python3.12
      CodeUri: ../source/lambda_functions/query_knowledgebase_resolver
      Description: Lambda function to query the meeting transcript knowledge base
      MemorySize: 512
      Timeout: 60
      Environment:
        Variables:
          KB_ID: !Ref BedrockKnowledgeBaseID
          KB_ACCOUNT_ID: !Ref AWS::AccountId
          KB_REGION: !Ref AWS::Region
          MODEL_ID: !Ref BedrockModelId
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/QueryKnowledgeBaseResolverFunction
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - QueryKnowledgeBaseResolverFunctionLogGroup

  MeetingInvitationParserFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt MeetingInvitationParserFunctionExecutionRole.Arn
      Runtime: python3.12
      CodeUri: ../source/lambda_functions/meeting_invitation_parser
      Description: Lambda function to parse meeting invitations using Bedrock AI
      MemorySize: 512
      Timeout: 60
      Environment:
        Variables:
          BEDROCK_MODEL_ID: !Ref BedrockModelId
          BEDROCK_REGION_OVERRIDE: !Ref AWS::Region
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/MeetingInvitationParserFunction
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - MeetingInvitationParserFunctionLogGroup

  MeetingInvitationParserFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/MeetingInvitationParserFunction
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  MeetingInvitationParserFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: Meeting Invitation Parser Function Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-MeetingInvitationParser
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "bedrock:InvokeModel"
                Resource:
                  - !Sub "arn:${AWS::Partition}:bedrock:*::foundation-model/*"
                  - !Sub "arn:${AWS::Partition}:bedrock:*:${AWS::AccountId}:custom-model/*"
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*"
              - Effect: Allow
                Action:
                  - "bedrock:GetInferenceProfile"
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*"

  QueryKnowledgeBaseResolverFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/QueryKnowledgeBaseResolverFunction
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  QueryKnowledgeBaseResolverFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: QueryKnowledgeBaseResolver Function Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-BedrockKnowledgeBase
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "bedrock:Retrieve"
                  - "bedrock:RetrieveAndGenerate"
                #TODO: Figure out how to restrict to target Transcript KB - created in a parallel nested stack
                Resource: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
              - Effect: Allow
                Action:
                  - "bedrock:InvokeModel"
                Resource: 
                  - !Sub "arn:aws:bedrock:*::foundation-model/*"
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*"
              - Effect: Allow
                Action:
                  - "bedrock:GetInferenceProfile"
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/*"

  AppSyncLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com
      Policies:
        - PolicyName: lambda
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: 
                  - !GetAtt QueryKnowledgeBaseResolverFunction.Arn
                  - !GetAtt MeetingInvitationParserFunction.Arn

  ##########################################################################
  # Meeting Controls Lambda - To share and delete meetings
  ##########################################################################
  MeetingControlsResolverFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt MeetingControlsResolverFunctionExecutionRole.Arn
      Runtime: python3.12
      Architectures:
        - arm64
      CodeUri: ../source/lambda_functions/meeting_controls_resolver
      Layers:
        - !Ref TranscriptEnrichmentPythonLayer
      Description: Lambda function for meeting controls
      MemorySize: 512
      Timeout: 60
      FunctionName: !Sub '${LMAStackName}-MeetingControlsLambda'
      Environment:
        Variables:
          LCA_CALL_EVENTS_TABLE: !Ref EventSourcingTable
          REACT_APP_AWS_REGION: !Ref AWS::Region
          REACT_APP_USER_POOL_ID: !Ref UserPoolId
          APPSYNC_GRAPHQL_URL: !GetAtt AppSyncApiEncrypted.GraphQLUrl
          S3_BUCKET_NAME: !Ref S3BucketName
          S3_RECORDINGS_PREFIX: !Ref AudioFilePrefix
          S3_TRANSCRIPTS_PREFIX: !Ref TranscriptFilePrefix
          VP_TABLE_NAME: !Ref VirtualParticipantTable
          VP_TASK_REGISTRY_TABLE_NAME: !Ref VPTaskRegistry
          KINESIS_STREAM_NAME: !Ref CallDataStream

      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/MeetingControlsResolverFunction
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data - only configuration values like feature flags and non-sensitive settings"
    DependsOn:
      - MeetingControlsResolverFunctionLogGroup

  MeetingControlsResolverFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/MeetingControlsResolverFunction
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  MeetingControlsResolverFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: MeetingControlsResolver Function Lambda Role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-MeetingControls
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                Resource: !GetAtt EventSourcingTable.Arn
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource: !Ref CustomerManagedEncryptionKeyArn
              - Effect: Allow
                Action:
                  - appsync:GraphQL
                Resource:
                  # XXX specific mutation - addEnrichment
                  - !Sub "${AppSyncApiEncrypted.Arn}/types/Mutation/*"
                  - !Sub "${AppSyncApiEncrypted.Arn}/types/Query/fields/__schema"
                  - !Sub "${AppSyncApiEncrypted.Arn}/types/Query/fields/getCall"
                  - !Sub "${AppSyncApiEncrypted.Arn}/types/Query/*"
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                  - "s3:DeleteObject"
                  - "s3:DeleteObjectVersion"
                  - "s3:ListBucket"
                Resource:
                  - !Sub "arn:aws:s3:::${S3BucketName}"
                  - !Sub "arn:aws:s3:::${S3BucketName}/*"
              - Effect: Allow
                Action:
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:DeleteItem
                Resource: 
                  - !GetAtt VirtualParticipantTable.Arn
                  - !GetAtt VPTaskRegistry.Arn
              - Effect: Allow
                Action:
                  - kinesis:PutRecord
                  - kinesis:PutRecords
                Resource: !Ref CallDataStreamArn
              - Effect: Allow
                Action:
                  - ecs:StopTask
                  - ecs:DescribeTasks
                Resource: "*"

  AppSyncMeetingControlsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com
      Policies:
        - PolicyName: lambda
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt MeetingControlsResolverFunction.Arn

  # AppSync Event API for MCP command delivery (separate from GraphQL API)
  AppSyncEventApi:
    Type: AWS::AppSync::Api
    Properties:
      Name: !Sub "MCPEvents-${AWS::StackName}"
      EventConfig:
        AuthProviders:
          - AuthType: AWS_IAM
        ConnectionAuthModes:
          - AuthType: AWS_IAM
        DefaultPublishAuthModes:
          - AuthType: AWS_IAM
        DefaultSubscribeAuthModes:
          - AuthType: AWS_IAM

  # Channel namespace for MCP commands
  MCPChannelNamespace:
    Type: AWS::AppSync::ChannelNamespace
    Properties:
      ApiId: !GetAtt AppSyncEventApi.ApiId
      Name: mcp-commands

  # Custom resource to get Event API DNS (not exposed by CloudFormation)
  GetEventApiDnsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: AppSyncGetApi
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - appsync:GetApi
                Resource: !Sub "arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/*"

  GetEventApiDnsFunction:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access
          - id: W92
            reason: Function does not require reserved concurrency
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    # checkov:skip=CKV_AWS_116: "DLQ not required for custom resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    Properties:
      Handler: index.handler
      Runtime: python3.12
      Timeout: 60
      Role: !GetAtt GetEventApiDnsRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          appsync_client = boto3.client('appsync')
          
          def handler(event, context):
              logger.info(f"Event: {event}")
              
              try:
                  request_type = event['RequestType']
                  
                  if request_type == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  api_id = event['ResourceProperties']['ApiId']
                  logger.info(f"Getting DNS for Event API: {api_id}")
                  
                  response = appsync_client.get_api(apiId=api_id)
                  dns = response['api']['dns']
                  realtime_dns = dns['REALTIME']
                  http_dns = dns['HTTP']
                  
                  logger.info(f"REALTIME DNS: {realtime_dns}")
                  logger.info(f"HTTP DNS: {http_dns}")
                  
                  websocket_url = f"wss://{realtime_dns}/event"
                  http_url = f"https://{http_dns}"
                  
                  response_data = {
                      'RealtimeDns': realtime_dns,
                      'HttpDns': http_dns,
                      'WebSocketUrl': websocket_url,
                      'HttpUrl': http_url
                  }
                  
                  logger.info(f"Response data: {response_data}")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  logger.error(f"Error: {e}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason=str(e))

  EventApiDns:
    Type: Custom::EventApiDns
    Properties:
      ServiceToken: !GetAtt GetEventApiDnsFunction.Arn
      ApiId: !GetAtt AppSyncEventApi.ApiId

  AppSyncApiEncrypted:
    Type: AWS::AppSync::GraphQLApi
    # checkov:skip=CKV2_AWS_33: "WAF protection is optional for AppSync API based on customer security requirements"
    Properties:
      Name: !Sub "CallAnalytics-${AWS::StackName}"
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      UserPoolConfig:
        AppIdClientRegex: !Ref CognitoClientId
        AwsRegion: !Ref AWS::Region
        UserPoolId: !Ref UserPoolId
        # XXX change to DENY and explicitly add access (e.g. Supervisors, Agent)
        DefaultAction: ALLOW
      AdditionalAuthenticationProviders:
        - AuthenticationType: AWS_IAM
      LogConfig:
        CloudWatchLogsRoleArn: !GetAtt AppSyncCwlRole.Arn
        ExcludeVerboseContent: false
        FieldLogLevel: ALL
      # Commenting out Xray as it causes issues with the ServiceLinked role on first deployment
      # similar to: https://github.com/aws/aws-cdk/issues/16598
      # XrayEnabled: true

  AppSyncSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DefinitionS3Location: ../source/appsync/schema.graphql

  AppSyncDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: CallEventSourcing
      Description: Call Analytics Event Sourcing DynamoDB Table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDbRole.Arn
      DynamoDBConfig:
        TableName: !Ref EventSourcingTable
        AwsRegion: !Ref AWS::Region

  SubscriptionDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: Subscription
      Description: NONE type data source to set up subscription filtering
      Type: NONE

  MeetingsDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: Meetings
      Description: Data source to share meetings
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt AppSyncMeetingControlsLambdaRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt MeetingControlsResolverFunction.Arn

  KnowledgeBaseDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: KnowledgeBase
      Description: Interface to Bedrock KB for meeting transcript queries
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt AppSyncLambdaRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt QueryKnowledgeBaseResolverFunction.Arn

  StrandsChatDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: StrandsChat
      Description: STRANDS Chat Interface for direct chat messages
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt AppSyncStrandsChatLambdaRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt StrandsChatInterfaceFunction.Arn

  MeetingInvitationParserDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: MeetingInvitationParser
      Description: Data source for parsing meeting invitations using Bedrock AI
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt AppSyncLambdaRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt MeetingInvitationParserFunction.Arn

  ChatButtonConfigDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: ChatButtonConfigTable
      Description: STRANDS Agent Chat Button Configuration DynamoDB Table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt ChatButtonConfigDataSourceRole.Arn
      DynamoDBConfig:
        TableName: !Ref ChatButtonConfigTableName
        AwsRegion: !Ref AWS::Region

  ChatButtonConfigDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: appsync.amazonaws.com
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                Resource: !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ChatButtonConfigTableName}"

  AppSyncStrandsChatLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com
      Policies:
        - PolicyName: lambda
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt StrandsChatInterfaceFunction.Arn

  AppSyncApiCache:
    Type: AWS::AppSync::ApiCache
    Condition: ShouldEnableAppSyncApiCache
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Type: !Ref AppSyncApiCacheInstanceType
      ApiCachingBehavior: PER_RESOLVER_CACHING
      Ttl: 30
      TransitEncryptionEnabled: true
      AtRestEncryptionEnabled: true

  GetCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: getCall
      RequestMappingTemplateS3Location: ../source/appsync/getCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/getCall.response.vtl

  CreateCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: createCall
      # This VTL uses a local sub so it needs to be kept here
      RequestMappingTemplate: !Sub |-
        #set( $shardsInDay = 6 )
        #set( $shardDivider = 24 / $shardsInDay )
        #set( $Integer = 0 )
        #set( $now = $ctx.args.input.CreatedAt )

        #set( $date = $now.substring(0, 10) )
        #set( $hourString = $now.substring(11, 13) )
        #set( $hour = $Integer.parseInt($hourString) )

        #set( $hourShard = $hour / $shardDivider )
        #set( $shardPad = $date.format("%02d", $hourShard) )

        #set( $PK = "c#${!ctx.args.input.CallId}" )

        #set( $listPk = "cls#${!date}#s#${!shardPad}" )
        #set( $listSk = "ts#${!now}#id#${!ctx.args.input.CallId}" )

        $util.qr($ctx.args.input.put("UpdatedAt", $now))
        $util.qr($ctx.args.input.put("Status", "STARTED"))

        {
          "version" : "2018-05-29",
          "operation" : "TransactWriteItems",
          "transactItems": [
            {
              "table": "${EventSourcingTable}",
              "operation": "PutItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($PK),
                "SK": $util.dynamodb.toDynamoDBJson($PK),
              },
              "attributeValues": $util.dynamodb.toMapValuesJson($ctx.args.input),
              "condition": {
                "expression": "attribute_not_exists(#PK)",
                "expressionNames": {
                  "#PK": "PK",
                },
              },
            },
            {
              "table": "${EventSourcingTable}",
              "operation": "PutItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($listPk),
                "SK": $util.dynamodb.toDynamoDBJson($listSk),
              },
              "attributeValues": {
                "CallId": $util.dynamodb.toDynamoDBJson($ctx.args.input.CallId),
                "CreatedAt": $util.dynamodb.toDynamoDBJson($ctx.args.input.CreatedAt),
                "UpdatedAt": $util.dynamodb.toDynamoDBJson($ctx.args.input.UpdatedAt),
                "ExpiresAfter": $util.dynamodb.toDynamoDBJson($ctx.args.input.ExpiresAfter),
                "Owner": $util.dynamodb.toDynamoDBJson($ctx.args.input.Owner)
              },
            },
          ],
        }
      ResponseMappingTemplateS3Location: ../source/appsync/createCall.response.vtl

  UpdateCallStatusAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateCallStatus
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  UpdateRecordingUrlAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateRecordingUrl
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  UpdatePcaUrlAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updatePcaUrl
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  UpdateAgentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateAgent
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  AddCallCategoryAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: addCallCategory
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  AddIssuesDetectedAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: addIssuesDetected
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  AddCallSummaryTextAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: addCallSummaryText
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  UpdateCallAggregationAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateCallAggregation
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  AddTranscriptSegmentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: addTranscriptSegment
      RequestMappingTemplateS3Location: ../source/appsync/addTranscriptSegment.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  DeleteTranscriptSegmentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: deleteTranscriptSegment
      RequestMappingTemplateS3Location: ../source/appsync/deleteTranscriptSegment.request.vtl
      ResponseMappingTemplate: "$util.toJson($context.result)"

  ShareTranscriptSegmentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: shareTranscriptSegment
      RequestMappingTemplateS3Location: ../source/appsync/shareTranscriptSegment.request.vtl
      ResponseMappingTemplate: "$util.toJson($context.arguments.input.PK)"

  ShareMeetingsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt MeetingsDataSource.Name
      TypeName: Mutation
      FieldName: shareMeetings
      Runtime: 
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/shareMeetings.js

  ShareCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: shareCall
      # This VTL uses a local sub so it needs to be kept here
      RequestMappingTemplate: !Sub |-
        #set( $PK = "c#${!ctx.args.input.CallId}" )
        {
          "version": "2018-05-29",
          "operation": "TransactWriteItems",
          "transactItems": [
            {
              "table": "${EventSourcingTable}",
              "operation": "UpdateItem",
              "key": {
                "PK": $util.dynamodb.toDynamoDBJson($PK),
                "SK": $util.dynamodb.toDynamoDBJson($PK),
              },
              "update": {
                "expression" : "SET SharedWith = :val", 
                "expressionValues" : {
                    ":val" : $util.dynamodb.toDynamoDBJson($ctx.args.input.SharedWith)
                },
              },
            },
            {
              "table": "${EventSourcingTable}",
              "operation": "UpdateItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($ctx.args.input.ListPK),
                "SK": $util.dynamodb.toDynamoDBJson($ctx.args.input.ListSK),
              },
              "update": {
                "expression" : "SET SharedWith = :val", 
                "expressionValues" : {
                    ":val" : $util.dynamodb.toDynamoDBJson($ctx.args.input.SharedWith)
                },
              },
            },
          ],
        }
      ResponseMappingTemplateS3Location: ../source/appsync/shareCall.response.vtl

  UnshareCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      TypeName: Mutation
      FieldName: unshareCall
      # This VTL uses a local sub so it needs to be kept here
      RequestMappingTemplateS3Location: ../source/appsync/unshareCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/unshareCall.response.vtl

  DeleteMeetingsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt MeetingsDataSource.Name
      TypeName: Mutation
      FieldName: deleteMeetings
      Runtime: 
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/deleteMeetings.js

  DeleteCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: deleteCall
      # This VTL uses a local sub so it needs to be kept here
      RequestMappingTemplate: !Sub |-
        #set( $PK = "c#${!ctx.args.input.CallId}" )
        {
          "version": "2018-05-29",
          "operation": "TransactWriteItems",
          "transactItems": [
            {
              "table": "${EventSourcingTable}",
              "operation": "DeleteItem",
              "key": {
                "PK": $util.dynamodb.toDynamoDBJson($PK),
                "SK": $util.dynamodb.toDynamoDBJson($PK),
              }
            },
            {
              "table": "${EventSourcingTable}",
              "operation": "DeleteItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($ctx.args.input.ListPK),
                "SK": $util.dynamodb.toDynamoDBJson($ctx.args.input.ListSK),
              },
            },
          ],
        }
      ResponseMappingTemplateS3Location: ../source/appsync/deleteCall.response.vtl

  ListCallsDateHourAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: listCallsDateHour
      RequestMappingTemplateS3Location: ../source/appsync/listCallsDateHour.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/listCalls.response.vtl

  ListCallsDateShardAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: listCallsDateShard
      RequestMappingTemplateS3Location: ../source/appsync/listCallsDateShard.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/listCalls.response.vtl

  ListCallsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: listCalls
      RequestMappingTemplateS3Location: ../source/appsync/listCalls.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/listCalls.response.vtl

  GetTranscriptSegmentsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: getTranscriptSegments
      RequestMappingTemplateS3Location: ../source/appsync/getTranscriptSegments.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/getTranscriptSegments.response.vtl

  GetTranscriptSegmentsWithSentimentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: getTranscriptSegmentsWithSentiment
      RequestMappingTemplateS3Location: ../source/appsync/getTranscriptSegmentsWithSentiment.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/getTranscriptSegmentsWithSentiment.response.vtl

  OnCreateCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onCreateCall
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/subscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  OnUpdateCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onUpdateCall
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/subscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  OnShareMeetingsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onShareMeetings
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/subscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  OnDeleteCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onDeleteCall
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/subscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  OnUnshareCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onUnshareCall
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/unshareCallSubscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  OnAddTranscriptSegmentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onAddTranscriptSegment
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/subscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  QueryKnowledgeBaseResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt KnowledgeBaseDataSource.Name
      TypeName: Query
      FieldName: queryKnowledgeBase
      Runtime: 
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/queryKnowledgeBase.js

  ParseMeetingInvitationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt MeetingInvitationParserDataSource.Name
      TypeName: Query
      FieldName: parseMeetingInvitation
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  GetChatButtonConfigResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt ChatButtonConfigDataSource.Name
      TypeName: Query
      FieldName: getChatButtonConfig
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      Code: |
        import { util } from '@aws-appsync/utils';
        
        export function request(ctx) {
          return {
            operation: 'GetItem',
            key: util.dynamodb.toMapValues({
              ChatButtonConfigId: ctx.args.ChatButtonConfigId
            })
          };
        }
        
        export function response(ctx) {
          if (ctx.error) {
            util.error(ctx.error.message, ctx.error.type);
          }
          
          // Return the full DynamoDB item as a JSON string in the ChatButtonConfigId field
          // This allows us to bypass GraphQL's field filtering
          return {
            ChatButtonConfigId: JSON.stringify(ctx.result)
          };
        }

  UpdateChatButtonConfigResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt ChatButtonConfigDataSource.Name
      TypeName: Mutation
      FieldName: updateChatButtonConfig
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/updateChatButtonConfig.js

  SendChatMessageResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt StrandsChatDataSource.Name
      TypeName: Mutation
      FieldName: sendChatMessage
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  AddChatTokenResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      TypeName: Mutation
      FieldName: addChatToken
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/addChatToken.js

  ToggleVNCPreviewResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: toggleVNCPreview
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/toggleVNCPreview.js

  OnVNCPreviewToggleResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onVNCPreviewToggle
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/onVNCPreviewToggle.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  OnUpdateVirtualParticipantAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Subscription
      FieldName: onUpdateVirtualParticipant
      DataSourceName: !GetAtt SubscriptionDataSource.Name
      CodeS3Location: ../source/appsync/subscription.js
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0

  ##########################################################################
  # Virtual Participant
  ##########################################################################
  VirtualParticipantTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-VirtualParticipant"
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
  # MCP Servers Table - Account-level MCP server configurations
  MCPServersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-MCPServers"
      AttributeDefinitions:
        - AttributeName: AccountId
          AttributeType: S
        - AttributeName: ServerId
          AttributeType: S
      KeySchema:
        - AttributeName: AccountId
          KeyType: HASH
        - AttributeName: ServerId
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref CustomerManagedEncryptionKeyArn

  # OAuth State Table - Temporary storage for OAuth flow state
  OAuthStateTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-OAuthState"
      AttributeDefinitions:
        - AttributeName: State
          AttributeType: S
      KeySchema:
        - AttributeName: State
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      TimeToLiveSpecification:
        AttributeName: ExpiresAt
        Enabled: true
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref CustomerManagedEncryptionKeyArn

  # OAuth Manager Lambda Function
  OAuthManagerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-OAuthManager"
      Handler: index.handler
      Runtime: python3.12
      CodeUri: ../source/lambda_functions/oauth_manager
      Description: Manages OAuth 2.1 flow for MCP servers
      MemorySize: 256
      Timeout: 30
      Environment:
        Variables:
          OAUTH_STATE_TABLE: !Ref OAuthStateTable
          MCP_SERVERS_TABLE: !Ref MCPServersTable
          KMS_KEY_ID: !Ref CustomerManagedEncryptionKeyArn
          OAUTH_CALLBACK_URL: !Sub "https://${WebAppCloudFrontDistribution.DomainName}/#/oauth/callback"
          AWS_ACCOUNT_ID: !Ref AWS::AccountId
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref OAuthStateTable
        - DynamoDBCrudPolicy:
            TableName: !Ref MCPServersTable
        - Statement:
            - Effect: Allow
              Action:
                - kms:Decrypt
                - kms:Encrypt
                - kms:DescribeKey
              Resource: !Ref CustomerManagedEncryptionKeyArn
      LoggingConfig:
        LogGroup: !Sub "/${AWS::StackName}/lambda/OAuthManager"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access
          - id: W92
            reason: Function does not require reserved concurrency
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    # checkov:skip=CKV_AWS_116: "DLQ not required for OAuth management function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data"
    DependsOn:
      - OAuthManagerLogGroup

  OAuthManagerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/OAuthManager"
      RetentionInDays: !Ref CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  # AppSync data source for OAuth Manager
  OAuthManagerDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: OAuthManager
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt OAuthManagerDataSourceRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt OAuthManagerFunction.Arn

  OAuthManagerDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: appsync.amazonaws.com
      Policies:
        - PolicyName: LambdaInvokePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt OAuthManagerFunction.Arn

  # AppSync Resolvers for OAuth Flow
  InitOAuthFlowResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: initOAuthFlow
      DataSourceName: !GetAtt OAuthManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "initOAuthFlow"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  HandleOAuthCallbackResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: handleOAuthCallback
      DataSourceName: !GetAtt OAuthManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "handleOAuthCallback"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  # Data source for Virtual Participant table
  VirtualParticipantDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: VirtualParticipantTable
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt VirtualParticipantDataSourceRole.Arn
      DynamoDBConfig:
        TableName: !Ref VirtualParticipantTable
        AwsRegion: !Ref AWS::Region

  VirtualParticipantDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: appsync.amazonaws.com
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                Resource: !GetAtt VirtualParticipantTable.Arn

  CreateVirtualParticipantResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: createVirtualParticipant
      DataSourceName: !GetAtt VirtualParticipantDataSource.Name
      RequestMappingTemplate: |
        #set($id = $util.autoId())
        #set($now = $util.time.nowISO8601())
        
        ## Build input map for DynamoDB
        #set($input = {})
        $util.qr($input.put("id", $id))
        $util.qr($input.put("meetingName", $ctx.args.input.meetingName))
        $util.qr($input.put("meetingPlatform", $ctx.args.input.meetingPlatform))
        $util.qr($input.put("meetingId", $ctx.args.input.meetingId))
        $util.qr($input.put("status", $ctx.args.input.status))
        $util.qr($input.put("owner", $ctx.identity.username))
        $util.qr($input.put("Owner", $ctx.identity.username))
        $util.qr($input.put("SharedWith", ""))
        $util.qr($input.put("createdAt", $now))
        $util.qr($input.put("updatedAt", $now))
        
        ## Add optional fields
        #if(!$util.isNullOrBlank($ctx.args.input.meetingPassword))
          $util.qr($input.put("meetingPassword", $ctx.args.input.meetingPassword))
        #end
        
        #if($ctx.args.input.meetingTime)
          $util.qr($input.put("meetingTime", $ctx.args.input.meetingTime))
          #set($meetingTimeMillis = $util.math.multiply($ctx.args.input.meetingTime, 1000))
          #set($scheduledDateTime = $util.time.epochMilliSecondsToISO8601($meetingTimeMillis))
          $util.qr($input.put("scheduledFor", $scheduledDateTime))
        #end
        
        #if(!$util.isNullOrBlank($ctx.args.input.isScheduled))
          $util.qr($input.put("isScheduled", $ctx.args.input.isScheduled))
        #end
        
        {
          "version": "2018-05-29",
          "operation": "PutItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($id)
          },
          "attributeValues": $util.dynamodb.toMapValuesJson($input)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  UpdateVirtualParticipantResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: updateVirtualParticipant
      DataSourceName: !GetAtt VirtualParticipantDataSource.Name
      RequestMappingTemplate: |
        #set( $UpdatedAt = $util.time.nowISO8601() )
        ## Set up tracking for dynamic updates **
        #set( $expNames = {} )
        #set( $expValues = {} )
        #set( $expSet = {} )
        
        ## Always update status and updatedAt **
        $util.qr( $expSet.put("#status", ":status") )
        $util.qr( $expNames.put("#status", "status") )
        $util.qr( $expValues.put(":status", $util.dynamodb.toDynamoDB($ctx.args.input.status)) )
        
        $util.qr( $expSet.put("#updatedAt", ":updatedAt") )
        $util.qr( $expNames.put("#updatedAt", "updatedAt") )
        $util.qr( $expValues.put(":updatedAt", $util.dynamodb.toDynamoDB($UpdatedAt)) )
        
        ## Add CallId if provided **
        #if( !$util.isNullOrBlank($ctx.args.input.CallId) )
            $util.qr( $expSet.put("#CallId", ":CallId") )
            $util.qr( $expNames.put("#CallId", "CallId") )
            $util.qr( $expValues.put(":CallId", $util.dynamodb.toDynamoDB($ctx.args.input.CallId)) )
        #end
        
        ## Add VNC fields if provided **
        #if( !$util.isNullOrBlank($ctx.args.input.vncEndpoint) )
            $util.qr( $expSet.put("#vncEndpoint", ":vncEndpoint") )
            $util.qr( $expNames.put("#vncEndpoint", "vncEndpoint") )
            $util.qr( $expValues.put(":vncEndpoint", $util.dynamodb.toDynamoDB($ctx.args.input.vncEndpoint)) )
        #end
        
        #if( !$util.isNull($ctx.args.input.vncPort) )
            $util.qr( $expSet.put("#vncPort", ":vncPort") )
            $util.qr( $expNames.put("#vncPort", "vncPort") )
            $util.qr( $expValues.put(":vncPort", $util.dynamodb.toDynamoDB($ctx.args.input.vncPort)) )
        #end
        
        #if( !$util.isNull($ctx.args.input.vncReady) )
            $util.qr( $expSet.put("#vncReady", ":vncReady") )
            $util.qr( $expNames.put("#vncReady", "vncReady") )
            $util.qr( $expValues.put(":vncReady", $util.dynamodb.toDynamoDB($ctx.args.input.vncReady)) )
        #end
        
        ## Add manual action fields if provided **
        #if( !$util.isNullOrBlank($ctx.args.input.manualActionType) )
            $util.qr( $expSet.put("#manualActionType", ":manualActionType") )
            $util.qr( $expNames.put("#manualActionType", "manualActionType") )
            $util.qr( $expValues.put(":manualActionType", $util.dynamodb.toDynamoDB($ctx.args.input.manualActionType)) )
        #end
        
        #if( !$util.isNullOrBlank($ctx.args.input.manualActionMessage) )
            $util.qr( $expSet.put("#manualActionMessage", ":manualActionMessage") )
            $util.qr( $expNames.put("#manualActionMessage", "manualActionMessage") )
            $util.qr( $expValues.put(":manualActionMessage", $util.dynamodb.toDynamoDB($ctx.args.input.manualActionMessage)) )
        #end
        
        #if( !$util.isNull($ctx.args.input.manualActionTimeoutSeconds) )
            $util.qr( $expSet.put("#manualActionTimeoutSeconds", ":manualActionTimeoutSeconds") )
            $util.qr( $expNames.put("#manualActionTimeoutSeconds", "manualActionTimeoutSeconds") )
            $util.qr( $expValues.put(":manualActionTimeoutSeconds", $util.dynamodb.toDynamoDB($ctx.args.input.manualActionTimeoutSeconds)) )
        #end
        
        #if( !$util.isNullOrBlank($ctx.args.input.manualActionStartTime) )
            $util.qr( $expSet.put("#manualActionStartTime", ":manualActionStartTime") )
            $util.qr( $expNames.put("#manualActionStartTime", "manualActionStartTime") )
            $util.qr( $expValues.put(":manualActionStartTime", $util.dynamodb.toDynamoDB($ctx.args.input.manualActionStartTime)) )
        #end
        
        ## Build the SET expression **
        #set( $expression = "SET" )
        #foreach( $entry in $expSet.entrySet() )
            #set( $expression = "${expression} ${entry.key} = ${entry.value}" )
            #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
            #end
        #end
        
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
          },
          "update": {
            "expression": "$expression",
            "expressionNames": $utils.toJson($expNames),
            "expressionValues": $utils.toJson($expValues)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  ListVirtualParticipantsResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Query
      FieldName: listVirtualParticipants
      DataSourceName: !GetAtt VirtualParticipantDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Scan"
        }
      ResponseMappingTemplateS3Location: ../source/appsync/listVirtualParticipants.response.vtl

  GetVirtualParticipantResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Query
      FieldName: getVirtualParticipant
      DataSourceName: !GetAtt VirtualParticipantDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "GetItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
          }
        }
      ResponseMappingTemplateS3Location: ../source/appsync/getVirtualParticipant.response.vtl


  # Virtual Participant Manager Lambda Function
  VirtualParticipantManagerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-VirtualParticipantManager"
      Handler: index.lambda_handler
      Runtime: python3.12
      CodeUri: ../source/lambda_functions/virtual_participant_manager
      Description: Enhanced Virtual Participant Manager with ECS termination and Kinesis events
      MemorySize: 512
      Timeout: 300
      Environment:
        Variables:
          TABLE_NAME: !Ref VirtualParticipantTable
          KINESIS_STREAM_NAME: !Ref CallDataStream
          VP_TASK_REGISTRY_TABLE_NAME: !Ref VPTaskRegistry
          VP_SCHEDULE_GROUP_NAME: !Ref VPScheduleGroupName
          ALB_LISTENER_ARN: !Ref VNCALBListener
          LOG_LEVEL: DEBUG
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref VirtualParticipantTable
        - Statement:
            - Effect: Allow
              Action:
                - kinesis:PutRecord
                - kinesis:PutRecords
                - kinesis:DescribeStream
              Resource: !Ref CallDataStreamArn
            - Effect: Allow
              Action:
                - ecs:ListClusters
                - ecs:ListTasks
                - ecs:DescribeTasks
                - ecs:StopTask
                - ecs:DescribeTaskDefinition
              Resource: "*"
            - Effect: Allow
              Action:
                - ecs:DescribeClusters
              Resource: !Sub "arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:cluster/*"
            - Effect: Allow
              Action:
                - dynamodb:GetItem
                - dynamodb:DeleteItem
              Resource: 
                - !GetAtt VPTaskRegistry.Arn
            - Effect: Allow
              Action:
                - dynamodb:ListTables
              Resource: "*"
            - Effect: Allow
              Action:
                - scheduler:DeleteSchedule
                - scheduler:GetSchedule
              Resource: 
                - !Sub "arn:aws:scheduler:${AWS::Region}:${AWS::AccountId}:schedule/${VPScheduleGroupName}/*"
            - Effect: Allow
              Action:
                - elasticloadbalancing:DescribeTargetGroups
                - elasticloadbalancing:DeleteTargetGroup
                - elasticloadbalancing:DescribeRules
                - elasticloadbalancing:DeleteRule
                - elasticloadbalancing:DeregisterTargets
                - elasticloadbalancing:DescribeTargetHealth
                - elasticloadbalancing:DescribeTags
              Resource: "*"
      LoggingConfig:
        LogGroup: !Sub "/${AWS::StackName}/lambda/VirtualParticipantManager"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement

  VirtualParticipantManagerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/VirtualParticipantManager"
      RetentionInDays: !Ref CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  # VP Task Registry Table - stores task ARNs for efficient termination
  VPTaskRegistry:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-VPTaskRegistry"
      AttributeDefinitions:
        - AttributeName: vpId
          AttributeType: S
      KeySchema:
        - AttributeName: vpId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      TimeToLiveSpecification:
        AttributeName: expiresAt
        Enabled: true

  # Lambda data source for VP Manager
  VirtualParticipantLambdaDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: VirtualParticipantLambda
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt VirtualParticipantLambdaDataSourceRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt VirtualParticipantManagerFunction.Arn

  # MCP Server Manager Lambda Function
  MCPServerManagerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-MCPServerManager"
      Handler: index.handler
      Runtime: python3.12
      CodeUri: ../source/lambda_functions/mcp_server_manager
      Description: Manages MCP server installation and configuration
      MemorySize: 256
      Timeout: 60
      Environment:
        Variables:
          MCP_SERVERS_TABLE: !Ref MCPServersTable
          CODEBUILD_PROJECT: !Ref MCPLayerBuildProject
          AWS_ACCOUNT_ID: !Ref AWS::AccountId
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref MCPServersTable
        - Statement:
            - Effect: Allow
              Action:
                - codebuild:StartBuild
                - codebuild:BatchGetBuilds
              Resource: !GetAtt MCPLayerBuildProject.Arn
            - Effect: Allow
              Action:
                - kms:Decrypt
                - kms:DescribeKey
              Resource: !Ref CustomerManagedEncryptionKeyArn
      LoggingConfig:
        LogGroup: !Sub "/${AWS::StackName}/lambda/MCPServerManager"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access
          - id: W92
            reason: Function does not require reserved concurrency
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    # checkov:skip=CKV_AWS_116: "DLQ not required for management function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    # checkov:skip=CKV_AWS_173: "Environment variables do not contain sensitive data"
    DependsOn:
      - MCPServerManagerLogGroup

  MCPServerManagerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/MCPServerManager"
      RetentionInDays: !Ref CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  # AppSync data source for MCP Server Manager
  MCPServerManagerDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      Name: MCPServerManager
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt MCPServerManagerDataSourceRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt MCPServerManagerFunction.Arn

  MCPServerManagerDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: appsync.amazonaws.com
      Policies:
        - PolicyName: LambdaInvokePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt MCPServerManagerFunction.Arn

  # AppSync Resolvers for MCP Server Management
  InstallMCPServerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: installMCPServer
      DataSourceName: !GetAtt MCPServerManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "installMCPServer"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  UninstallMCPServerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: uninstallMCPServer
      DataSourceName: !GetAtt MCPServerManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "uninstallMCPServer"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)
  
  UpdateMCPServerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: updateMCPServer
      DataSourceName: !GetAtt MCPServerManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "updateMCPServer"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

        $util.toJson($ctx.result)

  ListInstalledMCPServersResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Query
      FieldName: listInstalledMCPServers
      DataSourceName: !GetAtt MCPServerManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "listInstalledMCPServers"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  GetMCPServerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Query
      FieldName: getMCPServer
      DataSourceName: !GetAtt MCPServerManagerDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "Invoke",
          "payload": {
            "arguments": $utils.toJson($context.arguments),
            "identity": $utils.toJson($context.identity),
            "info": {
              "fieldName": "getMCPServer"
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  ##########################################################################
  # MCP Server Resources - Allow external applications to access LMA data
  # (Separate from existing MCP client functionality above)
  ##########################################################################
  
  # External App Cognito Client for MCP Server authentication (Authorization Code flow)
  MCPServerExternalAppClient:
    Type: AWS::Cognito::UserPoolClient
    Condition: ShouldEnableMCPServer
    Properties:
      ClientName: "LMA-MCPServer-ExternalApp-Client"
      UserPoolId: !Ref UserPoolId
      GenerateSecret: true
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      AllowedOAuthFlows:
        - code
      AllowedOAuthFlowsUserPoolClient: true
      AllowedOAuthScopes:
        - openid
        - email
        - profile
      CallbackURLs: !If
        - HasCustomMCPServerCallbackURLs
        - !Split [",", !Ref MCPServerCallbackURLs]
        - - !Sub "https://${WebAppCloudFrontDistribution.DomainName}/#/oauth/callback"
      LogoutURLs:
        - !Sub "https://${WebAppCloudFrontDistribution.DomainName}/"
      SupportedIdentityProviders:
        - COGNITO

  # MCP Server Gateway Execution Role
  MCPServerGatewayExecutionRole:
    Type: AWS::IAM::Role
    Condition: ShouldEnableMCPServer
    Properties:
      RoleName: !Sub "${LMAStackName}-MCPServerGatewayRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*"
      Policies:
        - PolicyName: InvokeLambdaPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt MCPServerAnalyticsFunction.Arn
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue

  # MCP Server Analytics Lambda
  MCPServerAnalyticsLogGroup:
    Type: AWS::Logs::LogGroup
    Condition: ShouldEnableMCPServer
    Properties:
      LogGroupName: !Sub "/${LMAStackName}/lambda/MCPServerAnalytics"
      RetentionInDays: !Ref CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  MCPServerAnalyticsFunction:
    Type: AWS::Serverless::Function
    Condition: ShouldEnableMCPServer
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access
          - id: W92
            reason: Function does not require reserved concurrency
    # checkov:skip=CKV_AWS_116: "DLQ not required for MCP handler"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    Properties:
      FunctionName: !Sub "${LMAStackName}-MCPServerAnalytics"
      CodeUri: ../source/lambda_functions/mcp_analytics/
      Handler: index.lambda_handler
      Runtime: python3.12
      Timeout: 900
      MemorySize: 1024
      Environment:
        Variables:
          LOG_LEVEL: INFO
          CALLS_TABLE: !Ref EventSourcingTable
          RECORDINGS_BUCKET: !Ref S3BucketName
          TRANSCRIPT_PREFIX: !Ref TranscriptFilePrefix
          TRANSCRIPT_KB_ID: !Ref BedrockKnowledgeBaseID
          MODEL_ARN: !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/${BedrockModelId}"
      LoggingConfig:
        LogGroup: !Ref MCPServerAnalyticsLogGroup
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Ref EventSourcingTable
        - S3ReadPolicy:
            BucketName: !Ref S3BucketName
        - Statement:
            - Effect: Allow
              Action:
                - bedrock:Retrieve
                - bedrock:RetrieveAndGenerate
              Resource: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
            - Effect: Allow
              Action:
                - kms:Decrypt
                - kms:DescribeKey
              Resource: !Ref CustomerManagedEncryptionKeyArn
    DependsOn:
      - MCPServerAnalyticsLogGroup

  # MCP Server Gateway (Native CloudFormation)
  MCPServerGateway:
    Type: AWS::BedrockAgentCore::Gateway
    Condition: ShouldEnableMCPServer
    DependsOn:
      - MCPServerAnalyticsFunction
      - MCPServerExternalAppClient
      - MCPServerGatewayExecutionRole
    Properties:
      Name: !Sub "${LMAStackName}-MCP-Gateway"
      Description: "LMA MCP Server Gateway for external application access"
      ProtocolType: MCP
      AuthorizerType: CUSTOM_JWT
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          DiscoveryUrl: !Sub "https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration"
          AllowedClients:
            - !Ref MCPServerExternalAppClient
      RoleArn: !GetAtt MCPServerGatewayExecutionRole.Arn
      Tags:
        Application: LMA
        Component: MCPServer

  # MCP Server Gateway Target (Lambda)
  MCPServerGatewayTarget:
    Type: AWS::BedrockAgentCore::GatewayTarget
    Condition: ShouldEnableMCPServer
    DependsOn: MCPServerGateway
    Properties:
      GatewayIdentifier: !Ref MCPServerGateway
      Name: "LMAAnalyticsTarget"
      Description: "LMA meeting analytics and transcript access tools"
      CredentialProviderConfigurations:
        - CredentialProviderType: GATEWAY_IAM_ROLE
      TargetConfiguration:
        Mcp:
          Lambda:
            LambdaArn: !GetAtt MCPServerAnalyticsFunction.Arn
            ToolSchema:
              InlinePayload:
                - Name: search_lma_meetings
                  Description: "Search across all meeting transcripts and summaries using natural language queries"
                  InputSchema:
                    Type: object
                    Properties:
                      query:
                        Type: string
                        Description: "Natural language search query"
                      startDate:
                        Type: string
                        Description: "Optional ISO 8601 start date"
                      endDate:
                        Type: string
                        Description: "Optional ISO 8601 end date"
                      maxResults:
                        Type: number
                        Description: "Maximum results to return"
                    Required:
                      - query
                - Name: get_meeting_transcript
                  Description: "Retrieve the complete transcript for a specific meeting"
                  InputSchema:
                    Type: object
                    Properties:
                      meetingId:
                        Type: string
                        Description: "Meeting ID (CallId)"
                      format:
                        Type: string
                        Description: "Output format (json, text, or srt)"
                    Required:
                      - meetingId
                - Name: get_meeting_summary
                  Description: "Get AI-generated summary and action items for a meeting"
                  InputSchema:
                    Type: object
                    Properties:
                      meetingId:
                        Type: string
                        Description: "Meeting ID (CallId)"
                      includeActionItems:
                        Type: boolean
                        Description: "Include action items"
                      includeTopics:
                        Type: boolean
                        Description: "Include key topics"
                    Required:
                      - meetingId
                - Name: list_meetings
                  Description: "List meetings with optional filters"
                  InputSchema:
                    Type: object
                    Properties:
                      startDate:
                        Type: string
                        Description: "ISO 8601 start date"
                      endDate:
                        Type: string
                        Description: "ISO 8601 end date"
                      participant:
                        Type: string
                        Description: "Filter by participant name"
                      status:
                        Type: string
                        Description: "Meeting status filter"
                      limit:
                        Type: number
                        Description: "Maximum number of meetings to return"

  VirtualParticipantLambdaDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: appsync.amazonaws.com
      Policies:
        - PolicyName: LambdaInvokePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt VirtualParticipantManagerFunction.Arn

  EndVirtualParticipantResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: endVirtualParticipant
      DataSourceName: !GetAtt VirtualParticipantLambdaDataSource.Name
      Runtime:
        Name: APPSYNC_JS
        RuntimeVersion: 1.0.0
      CodeS3Location: ../source/appsync/endVirtualParticipant.js

  ShareVirtualParticipantResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: shareVirtualParticipant
      DataSourceName: !GetAtt VirtualParticipantDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
          },
          "update": {
            "expression": "SET SharedWith = :val",
            "expressionValues": {
              ":val": $util.dynamodb.toDynamoDBJson($util.str.join($ctx.args.input.SharedWith, ","))
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson({
          "id": $ctx.args.input.id,
          "Owner": $ctx.args.input.Owner,
          "SharedWith": $util.str.join($ctx.args.input.SharedWith, ",")
        })

  UnshareVirtualParticipantResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApiEncrypted.ApiId
      TypeName: Mutation
      FieldName: unshareVirtualParticipant
      DataSourceName: !GetAtt VirtualParticipantDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
          },
          "update": {
            "expression": "SET SharedWith = :val",
            "expressionValues": {
              ":val": $util.dynamodb.toDynamoDBJson("")
            }
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson({
          "id": $ctx.args.input.id,
          "SharedWith": $ctx.args.input.SharedWith
        })


  ##########################################################################
  # Lambda@Edge for VNC Authentication
  ##########################################################################

  # IAM Role for Lambda@Edge function (must be assumable by both lambda and edgelambda)
  EdgeAuthFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue

  # Custom resource Lambda to deploy Lambda@Edge in us-east-1
  EdgeAuthDeployerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: ManageLambdaEdge
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:CreateFunction
                  - lambda:UpdateFunctionCode
                  - lambda:UpdateFunctionConfiguration
                  - lambda:DeleteFunction
                  - lambda:GetFunction
                  - lambda:ListVersionsByFunction
                  - lambda:PublishVersion
                Resource: !Sub 'arn:aws:lambda:us-east-1:${AWS::AccountId}:function:${AWS::StackName}-VNCEdgeAuth*'
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt EdgeAuthFunctionRole.Arn

  EdgeAuthDeployerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-EdgeAuthDeployer'
      Handler: index.handler
      Runtime: python3.12
      Timeout: 60
      MemorySize: 256
      Role: !GetAtt EdgeAuthDeployerRole.Arn
      CodeUri: ../source/lambda_functions/edge_auth_deployer
      LoggingConfig:
        LogGroup: !Sub '/${AWS::StackName}/lambda/EdgeAuthDeployer'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access
          - id: W92
            reason: Function does not require reserved concurrency
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    # checkov:skip=CKV_AWS_116: "DLQ not required for custom resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    DependsOn:
      - EdgeAuthDeployerLogGroup

  EdgeAuthDeployerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/${AWS::StackName}/lambda/EdgeAuthDeployer'
      RetentionInDays: !Ref CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  # Custom resource to create Lambda@Edge function in us-east-1
  EdgeAuthFunction:
    Type: Custom::EdgeAuthFunction
    Properties:
      ServiceToken: !GetAtt EdgeAuthDeployerFunction.Arn
      FunctionName: !Sub '${AWS::StackName}-VNCEdgeAuth'
      RoleArn: !GetAtt EdgeAuthFunctionRole.Arn
      UserPoolId: !Ref UserPoolId
      Region: !Ref AWS::Region
      ClientId: !Ref CognitoClientId
      # Hash of the Lambda@Edge code - changing this forces the custom resource to update
      # This value is replaced during the build process by the Makefile
      CodeHash: "EDGE_AUTH_CODE_HASH_PLACEHOLDER"

  ##########################################################################
  # VNC Application Load Balancer for VNC Viewer Remove FrameBuffer Stream
  ##########################################################################

  # Custom resource to get CloudFront prefix list ID dynamically
  GetCloudFrontPrefixListRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: DescribePrefixLists
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeManagedPrefixLists
                Resource: '*'

  GetCloudFrontPrefixListFunction:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Function does not require VPC access
          - id: W92
            reason: Function does not require reserved concurrency
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    Properties:
      Handler: index.handler
      Runtime: python3.12
      Timeout: 60
      Role: !GetAtt GetCloudFrontPrefixListRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          
          def handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  ec2 = boto3.client('ec2')
                  response = ec2.describe_managed_prefix_lists(
                      Filters=[
                          {
                              'Name': 'prefix-list-name',
                              'Values': ['com.amazonaws.global.cloudfront.origin-facing']
                          }
                      ]
                  )
                  
                  if response['PrefixLists']:
                      prefix_list_id = response['PrefixLists'][0]['PrefixListId']
                      print(f"Found CloudFront prefix list: {prefix_list_id}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                                     {'PrefixListId': prefix_list_id})
                  else:
                      cfnresponse.send(event, context, cfnresponse.FAILED, {},
                                     reason='CloudFront prefix list not found')
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {},
                                 reason=str(e))

  CloudFrontPrefixList:
    Type: Custom::CloudFrontPrefixList
    Properties:
      ServiceToken: !GetAtt GetCloudFrontPrefixListFunction.Arn

  # ECS Security Group for Virtual Participant tasks
  VPSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Virtual Participant ECS tasks
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
          IpProtocol: "-1"
      Tags:
        - Key: Name
          Value: !Sub ${LMAStackName}-vp-sg

  # ALB Security Group - Allow traffic from CloudFront only
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for VNC Application Load Balancer
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourcePrefixListId: !GetAtt CloudFrontPrefixList.PrefixListId
          Description: Allow HTTP from CloudFront
      Tags:
        - Key: Name
          Value: !Sub ${LMAStackName}-alb-sg

  # Security group rules between ALB and ECS
  ALBToECSEgressRule:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref ALBSecurityGroup
      IpProtocol: tcp
      FromPort: 5901
      ToPort: 5901
      DestinationSecurityGroupId: !Ref VPSecurityGroup
      Description: Allow traffic to ECS tasks on websockify port

  ECSFromALBIngressRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref VPSecurityGroup
      IpProtocol: tcp
      FromPort: 5901
      ToPort: 5901
      SourceSecurityGroupId: !Ref ALBSecurityGroup
      Description: Allow websockify traffic from ALB

  # Application Load Balancer
  VNCALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: application
      Scheme: internet-facing
      IpAddressType: ipv4
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${LMAStackName}-vnc-alb

  # Target Group for ECS tasks
  VNCTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Port: 5901
      Protocol: HTTP
      TargetType: ip
      VpcId: !Ref VPC
      HealthCheckEnabled: true
      HealthCheckProtocol: HTTP
      HealthCheckPath: /
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: "30"
      Tags:
        - Key: Name
          Value: !Sub ${LMAStackName}-vnc-tg

  # HTTP Listener (port 80)
  VNCALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref VNCALB
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref VNCTargetGroup

  ##########################################################################
  # Web Site
  ##########################################################################

  # Custom resource to empty and delete WebApp bucket when stack is deleted

  BucketDeleteLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "s3:DeleteBucket"
                  - "s3:ListBucket"
                  - "s3:ListBucketVersions"
                  - "s3:DeleteObject"
                  - "s3:DeleteObjectVersion"
                Resource:
                  - !Sub "arn:aws:s3:::${WebAppBucket}"
                  - !Sub "arn:aws:s3:::${WebAppBucket}/*"
          PolicyName: deleteBucketS3Policy

  BucketDeleteLambda:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency as it scales based on demand"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access as it only interacts with AWS services via APIs"
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.lambda_handler"
      Runtime: python3.12
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt BucketDeleteLambdaRole.Arn
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          def deleteS3Bucket(bucketName):
             print("Deleting S3 Bucket %s" % bucketName)
             bucket = boto3.resource("s3").Bucket(bucketName)
             bucket.object_versions.all().delete()
             bucket.delete()
          def lambda_handler(event, context):
            print(event)
            responseData = {}
            status = cfnresponse.SUCCESS
            reason = "Success"
            if event['RequestType'] == 'Delete':
              try:
                deleteS3Bucket(event['ResourceProperties']['BucketName'])
              except Exception as e:
                print(e)
                reason = f"Exception thrown: {e}"
                status = cfnresponse.FAILED
            cfnresponse.send(event, context, status, responseData, reason=reason)
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/BucketDeleteLambda
    DependsOn:
      - BucketDeleteLambdaLogGroup

  BucketDeleteLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/BucketDeleteLambda
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  # Lambda to upload QuickSight manifest file
  UploadManifestLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary: !If
        - HasPermissionsBoundary
        - !Ref PermissionsBoundaryArn
        - !Ref AWS::NoValue
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "s3:PutObject"
                  - "s3:DeleteObject"
                Resource:
                  - !Sub "arn:aws:s3:::${S3BucketName}/quicksight-recordingsbucket-manifest.json"
          PolicyName: uploadManifestS3Policy

  UploadManifestLambda:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    # checkov:skip=CKV_AWS_115: "Function does not require reserved concurrency"
    # checkov:skip=CKV_AWS_116: "DLQ not required for Cfn Custom Resource function"
    # checkov:skip=CKV_AWS_117: "Function does not require VPC access"
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.lambda_handler"
      Runtime: python3.12
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt UploadManifestLambdaRole.Arn
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import cfnresponse
          
          def lambda_handler(event, context):
            print(event)
            responseData = {}
            status = cfnresponse.SUCCESS
            reason = "Success"
            
            if event['RequestType'] in ['Create', 'Update']:
              try:
                s3 = boto3.client('s3')
                bucket_name = event['ResourceProperties']['BucketName']
                prefix = event['ResourceProperties']['Prefix']
                
                # Standard manifest for nested JSON
                manifest = {
                  "fileLocations": [
                    {
                      "URIPrefixes": [
                        f"s3://{bucket_name}/{prefix}"
                      ]
                    }
                  ],
                  "globalUploadSettings": {
                    "format": "JSON"
                  }
                }
                
                s3.put_object(
                  Bucket=bucket_name,
                  Key='quicksight-recordingsbucket-manifest.json',
                  Body=json.dumps(manifest, indent=2),
                  ContentType='application/json'
                )
                
                print(f"Uploaded manifest to s3://{bucket_name}/quicksight-recordingsbucket-manifest.json")
                
              except Exception as e:
                print(e)
                reason = f"Exception thrown: {e}"
                status = cfnresponse.FAILED
                
            elif event['RequestType'] == 'Delete':
              try:
                s3 = boto3.client('s3')
                bucket_name = event['ResourceProperties']['BucketName']
                s3.delete_object(
                  Bucket=bucket_name,
                  Key='quicksight-recordingsbucket-manifest.json'
                )
                print(f"Deleted manifest from s3://{bucket_name}/quicksight-recordingsbucket-manifest.json")
              except Exception as e:
                print(e)
                # Don't fail on delete errors
                
            cfnresponse.send(event, context, status, responseData, reason=reason)
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/UploadManifestLambda
    DependsOn:
      - UploadManifestLambdaLogGroup

  UploadManifestLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /${AWS::StackName}/lambda/UploadManifestLambda
      RetentionInDays:
        Ref: CloudWatchLogsExpirationInDays
      KmsKeyId: !Ref CustomerManagedEncryptionKeyArn

  UploadQuickSightManifest:
    Type: Custom::UploadQuickSightManifest
    Properties:
      ServiceToken: !GetAtt UploadManifestLambda.Arn
      BucketName: !Ref S3BucketName
      Prefix: !Ref TranscriptFilePrefix

  RemoveWebAppBucketOnDelete:
    Type: Custom::RemoveWebAppBucketOnDelete
    Properties:
      ServiceToken: !GetAtt BucketDeleteLambda.Arn
      BucketName: !Ref WebAppBucket

  WebAppBucket:
    Type: AWS::S3::Bucket
    # checkov:skip=CKV_AWS_18: "Access logging configured via LoggingConfiguration property"
    Properties:
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucketName
        LogFilePrefix: "webapp-bucket-logs/"
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html

  WebAppBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebAppBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              CanonicalUser: !GetAtt CloudFrontOriginAccessIdentity.S3CanonicalUserId
            Action: s3:GetObject
            Resource: !Sub "${WebAppBucket.Arn}/*"
          - Effect: "Deny"
            Action:
              - "s3:*"
            Principal: "*"
            Resource:
              - !GetAtt WebAppBucket.Arn
              - !Sub "${WebAppBucket.Arn}/*"
            Condition:
              Bool:
                "aws:SecureTransport": false

  CloudFrontOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub "CloudFront OAI for ${WebAppBucket}"

  WebAppCloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    # checkov:skip=CKV_AWS_86: "CloudFront access logging configured via Logging property"
    # checkov:skip=CKV_AWS_174: "TLS v1.2 enforced via ViewerCertificate configuration"
    # checkov:skip=CKV_AWS_68: "WAF protection is optional for this distribution based on customer requirements"
    Properties:
      DistributionConfig:
        Comment: !Sub "Web app cloudfront distribution ${AWS::StackName}"
        Logging:
          Bucket: !Sub "${LoggingBucketName}.s3.amazonaws.com"
          Prefix: "cloudfront-logs/"
          IncludeCookies: false
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
          MinimumProtocolVersion: TLSv1.2_2021
        CustomErrorResponses:
          # Send errors to index file
          - ErrorCachingMinTTL: 300
            ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCachingMinTTL: 300
            ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          TargetOriginId: webapp-s3-bucket
          ViewerProtocolPolicy: redirect-to-https
          DefaultTTL: 600
          MinTTL: 300
          MaxTTL: 900
        DefaultRootObject: index.html
        Enabled: true
        HttpVersion: http2
        IPV6Enabled: true
        Origins:
          - Id: webapp-s3-bucket
            DomainName: !GetAtt WebAppBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: !Sub "origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}"
          - Id: vnc-alb
            DomainName: !GetAtt VNCALB.DNSName
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: http-only
        CacheBehaviors:
          - PathPattern: /vnc/*
            TargetOriginId: vnc-alb
            ViewerProtocolPolicy: https-only
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
              - PUT
              - POST
              - PATCH
              - DELETE
            CachedMethods:
              - GET
              - HEAD
            ForwardedValues:
              QueryString: true
              Headers:
                - "*"
              Cookies:
                Forward: all
            Compress: false
            DefaultTTL: 0
            MinTTL: 0
            MaxTTL: 0
            LambdaFunctionAssociations:
              - EventType: viewer-request
                LambdaFunctionARN: !GetAtt EdgeAuthFunction.FunctionArn
        PriceClass: !Ref CloudFrontPriceClass
        Restrictions: !If
          - ShouldEnableGeoRestriction
          - GeoRestriction:
              RestrictionType: whitelist
              Locations: !Split [",", !Ref CloudFrontAllowedGeos]
          - GeoRestriction:
              RestrictionType: none
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W70
            reason:
              This is using Cloudfront default TLS, can be changed by customer
              if needed.
